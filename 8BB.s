.ORG $080D		
JMP START

.SEGMENT "STARTUP"
.SEGMENT "INIT"
.SEGMENT "ONCE"
.SEGMENT "CODE"

;ZEROPAGE VARS START @ $30
KEYCODE = $30
POINTER = $31	;AND $32
CONTR = $33		;$33-$34
POINTER2 = $35;-$36
DEFAULTIRQVECTOR = $37;-#38
SEED = $39;-$3A
TMPY = $3B
TMPX = $3C
TMPA = $3D
CHUNKBCDX = $3E;-$3F
CHUNKBCDY = $40;-$41
GLOBALCOMPASS = $42;-$45
CURRENTINV = $46
VBUFFPOINTER = $47;-$48
COMPASSPOINTER = $49;-%51
COMPASSTMP = $52;-$55
STOREPOSITION = $56;-$57
BLOCKTYPE = $58;-$59
SETFRAME = $5A	;IF SET TO 0, THE VSYNC HANDLER WILL NOT RUN ANY GAME CODE
FA = $5B
FB = $5C
CHUNKPOINTER = $5D;-5E
LOADPOSITION = $60;-$61
DRAWSIZE = $62;-$63
CURRENTLINE = $64
INAIR = $65
COMPASSOFFSET = $66;-$67	TWO BYTES EACH FOR X & Y
PALOFFPOINTER = $68;-69
TILEOFFSET = $6A;-$6D
JUMP = $70
CURSORBLOCK = $71
INVFLAGS = $72
	;xxxx2SUO
	;|||||||- INVENTORY OPEN
	;||||||-- NEED TO UPDATE INVENTORY CURSOR SPRITES
	;|||||--- START HELD
	;||||---- 2ND INVENTORY CURSOR IS ON
MINEFLAGS = $73
	;MAxxTIME
	;-------- M: CURRENTLY MINING
	;|------- A: A BUTTON IS HELD DOWN (MUST BE RAISED BEFORE BLOCK CAN BE PLACED
	;||||---- TIME: CURRENT COUNTING OF PASSED MTIMESLICE
	
SLOWCLOCK = $7E
LOADINGERROR = $7F	;MAX FREE ZERO PAGE VALUE

IRQVEC = $0314

;VERA VARS & OTHER KERNEL THINGS
;[
RAMBANK 	 = $0000
ADDRL     	 = $9F20
ADDRM    	 = $9F21
ADDRH    	 = $9F22
DATA0        = $9F23
DATA1		 = $9F24
CTRL         = $9F25
IEN          = $9F26
ISR          = $9F27
VSYNC_BIT    = $01
DC_VIDEO     = $9F29
DC_HSCALE    = $9F2A
DC_VSCALE    = $9F2B
L0_CONFIG    = $9F2D
L0_MAPBASE   = $9F2E
L0_TILEBASE  = $9F2F
L0_HSCROLL_L = $9F30
L0_HSCROLL_H = $9F31
L0_VSCROLL_L = $9F32
L0_VSCROLL_H = $9F33
L1_CONFIG    = $9F34
L1_MAPBASE   = $9F35
L1_TILEBASE  = $9F36
L1_HSCROLL_L = $9F37
L1_HSCROLL_H = $9F38
L1_VSCROLL_L = $9F39
L1_VSCROLL_H = $9F3A
SCANLINE_L 	 = $9F28

;KERNEL API
MEMTOP = $FF99 
JOYSTICK_SCAN = $FF53
JOYSTICK_GET = $FF56	;//ID LOADED INTO A
						;//RETURNS IN A AND X
RNG0 = $FE57	;GENERATE RANDOM FLOATING POINT NUMBER

;FILE IO
SETLFS = $FFBA
SETNAM = $FFBD
LOAD = $FFD5
SAVE = $FFD8

;KERNEL FUNCTIONS:
GETIN = $FFE4	;LOADS INTO A ACCULATER, 0 UNTIL HAS 0 KEY IN KEYBOARD BUFFER, KEEP CALLING UNTIL IT RETURNS 0
CHRIN = $FFCF
SCREEN = $FFED
CHAROUT = $FFD2
;]


RNG:	;RETURNS IN A, SCRAMBLES Y
;[
	LDY #$08     ; iteration count (generates 8 bits)
	LDA SEED+0
:
	ASL        ; shift the register
	ROL SEED+1
	BCC :+
	EOR #$39   ; apply XOR feedback whenever a 1 bit is shifted out
:
	DEY
	BNE :--
	STA SEED+0
	CMP #$00     ; reload flags
	RTS
;]

START:	
;[	SETUP
	CLD	;CLEAR DECIMAL MODE
	
	;SET LOADING BACKGROUND TO BLACK
	
		
	;RANDOM SEED
	LDA #$88
	STA SEED
	LDA #$23
	STA SEED
	
	;INTERUPTS
	;GET DEFAULT
		LDA IRQVEC
		STA DEFAULTIRQVECTOR
		LDA IRQVEC+1
		STA DEFAULTIRQVECTOR+1
	SEI	;DISABLE INTERUPS
	;SET CUTOM INTERUPT HANDLER
		LDA #<VYSNCHANDLER
		STA IRQVEC
		LDA #>VYSNCHANDLER
		STA IRQVEC+1
		LDA #$01	;ONLY PRODUCE VSYNC INTERUPTS:
		STA IEN
	
	LOADPROGRAM:	;TITLE SCREEN CALLED HERE
	
	;VIDEO
	LDA DC_VIDEO
	AND #%000001111
	STA DC_VIDEO	;DISABLE VERA OUTPUT (BUT SHOULD SAVE THE OUTPUT MODE)
	
	LDA #32			;DISPLAY_SCALE	;32 for 160X120, 64 for 320x240, 128 for 640x480
	STA DC_VSCALE
	STA DC_HSCALE	;SET DISPLAY TO 320x240
	
	;LAYER 0
	;LDA #$70		;$0E000
	;STA L0_MAPBASE	NOT USED IN BITMAP MODE
	LDA #%00000111	;BITMAP 8BPP MODE
	STA L0_CONFIG
	STA L1_CONFIG
	LDA #$00	;BITMAP DATA @ $00000, 320 WIDTH BITMAP
	STA L0_TILEBASE
	LDA #$4C	;BITMAP DATA @ $09800, 320 WIDTH BITMAP
	STA L1_TILEBASE
		
	;NO SCROLL
	LDA #$00
	STA L0_HSCROLL_H
	STA L0_HSCROLL_L
	STA L0_VSCROLL_H
	STA L0_VSCROLL_L
	STA L1_HSCROLL_H
	STA L1_HSCROLL_L
	STA L1_VSCROLL_H
	STA L1_VSCROLL_L

	
	;LOAD IN TILES
	JSR LOADFILES
	JSR SETSTARTINGVARS
	
	LDA #$01
	STA SETFRAME	;ALLOW VSYNC GAME CODE

	;LAYERS
	LDA DC_VIDEO
	ORA #%00010000	;SET SPRITES, LAYER 1, LAYER 0, OUTPUT DIRECTED BY USER
	STA DC_VIDEO	;ENABLING VERA OUTPUT
	
	CLI	;ENABLE INTERUPTS
	
	JSR MEMTOP	;CHECK TO SEE IF THERE IS ENOUGH SYSTEM MEMORY
		
	JMP USEKEY
;]

SETUPWORLD:
;[
	;SETUP:
	;LOAD IN A FEW SPRITES
	JSR SETSPRITES
	JSR SETINVENTORYSLOTXY
	;CLEAR TILES
	JSR CLEARVERAANDBUFFER	
	;LOAD IN CHUNKS
	JSR LOADINITIALCHUNKS
	;SET INITIAL VRAM:
	JSR RESETRENDERCHUNKS
	JSR RENDERCHUNKS
	JSR VRAMBUFFERTOVERA
	;SETUP INVENTORY
	JSR DRAWITEMBAR
	;SET INV CURSORS
	JSR DRAWINVCURSORS
	RTS
;]

SETSTARTINGVARS:
;[
	LDA #$4F
	STA PLAYERCOR
	LDA #$20
	STA PLAYERCOR+1
	LDA #$0F
	STA CURRENTZ

	LDA #$50
	STA GLOBALCOMPASS
	STA GLOBALCOMPASS+2	
	LDA #$00
	STA GLOBALCOMPASS+1
	STA GLOBALCOMPASS+3;SET DEFAULT CHUNK TO 5000, 5000
	LDA #$00
	STA COMPASSOFFSET
	STA COMPASSOFFSET+1
	STA TILEOFFSET
	STA TILEOFFSET+1
	STA TILEOFFSET+2
	STA TILEOFFSET+3
	STA MFLAG
	
	LDA #$00
	STA SETFRAME
	STA INAIR
	STA JUMP
	STA CURRENTINV
	STA INVFLAGS
	STA RELOAD
	
	STA OVERLAYON
	JSR SETSPRITEOVERLAY
	
	LDA #$00
	STA SCROLLOFFSET
	LDA #$06
	STA SCROLLOFFSET+1
	
	JSR CREATIVEINVENTORY
	
	LDA #$01
		STA TITLEFLAGS	;TURN TITLE ON, NOT YET LOADED
	
	RTS
;]

SCREENSHOT:
;[	TAKE A SCREENSHOT
	LDA #$02
	STA $9FB5
	LDA #$01
	STA $9FB5
	LDX #$00
	LDY #$00
	:
		INX
		CPX #$00
		BNE :-
		INY
		CPY #$00
		BNE :-
	LDX #$00
	LDY #$00
	:
		INX
		CPX #$00
		BNE :-
		INY
		CPY #$00
		BNE :-
	LDA #$00
	STA $9FB5
	RTS

;INPUT:
WAITKEY:
	JSR GETIN
	CMP #$00
	BEQ WAITKEY
	STA KEYCODE
	JMP USEKEY
DRAIN:
	JSR GETIN
	CMP #$00
	BNE DRAIN	;SIMPLY DRAINS THE KEY BUFFER AWAY, IDEALY SHOULD USE IT
	JMP WAITKEY

USEKEY:	
	LDA KEYCODE
	CMP #$20
	BNE :+
		JSR SCREENSHOT
	:
ENDUSEKEY:
	JMP WAITKEY
;]


VYSNCHANDLER:	;MAIN PROGRAM LOOP
;[
	LDA ISR
	AND #$01
	BNE :+
		JMP ENDVSYNCHANDLER	;NOT A VSYNC INTERUPT
	:
	
	LDA RELOAD
	BEQ :+
		JSR JOYSTICK_SCAN
		LDA #$01	;ATTEMPT TO GET JOY[1] --> PLUGGED IN
		JSR JOYSTICK_GET
		CMP #$FF
		BNE SKIPHANDLE
		CPX #$FF
		BNE SKIPHANDLE	;IF CONTROLLER 0 AND 1 ARE NOT COMPLETLEY EMPTY, THEN DO NOT RESTART
		JSR JOYSTICK_SCAN
		LDA #$00	;ATTEMPT TO GET JOY[1] --> PLUGGED IN
		JSR JOYSTICK_GET
		CMP #$FF
		BNE SKIPHANDLE
		CPX #$FF
		BNE SKIPHANDLE	;IF CONTROLLER 0 AND 1 ARE NOT COMPLETLEY EMPTY, THEN DO NOT RESTART
		JSR CLEARVERAANDBUFFER
		JMP LOADPROGRAM
	:

;[	TITLE HANDLER:
	LDA TITLEFLAGS
	CMP #$00
	BEQ AFTERTITLE
	JMP TITLEHANDLER
;]
	AFTERTITLE:

;[	RERENDERING
	;COPY:
	LDA MFLAG
	AND #%10000000
	BEQ :+	;ALWAYS OCCURS AT SCANLINE 480
		LDA #$00
		STA SETFRAME
		;JSR CLEARBUFFERE
		JSR RENDERCHUNKS
		JSR VRAMBUFFERTOVERA
		LDA MFLAG
		AND #%01111111	; THIS BIT OFF
		STA MFLAG
		;SET ADJUSTED PLAYERCOR
		JSR SETPLAYERCORTOPLAYER
		LDA #$FF
		STA CONTR
		STA CONTR+1
		LDA #$01
		STA SETFRAME
	:
;]	

	INC SLOWCLOCK
	LDA SLOWCLOCK
	CMP CLOCKMAX
	BEQ HANDLE
	SKIPHANDLE:
		JMP ENDVSYNCHANDLER
HANDLE:
	
	LDA #$00
	STA SLOWCLOCK
	
	LDA SETFRAME	;0 TO NOT CONTINUE TO HANDLING
	CMP #$00
	BNE :+
		JMP ENDVSYNCHANDLER
	:
	
;[ CONTROLLER HANDLING
	;CHECK JOYSTICK:
	JSR JOYSTICK_SCAN
	
	LDA #$01	;ATTEMPT TO GET JOY[1] --> PLUGGED IN
	JSR JOYSTICK_GET
	;STORE CONTROLLER
	CPY #$FF	;THIS ISN'T NEGATIVE ONE, BUT IT SHOULD BE
	BNE :+
		;NO JOY[1] GET JOY[0] (KEYBOARD)
		JSR JOYSTICK_SCAN
		LDA #$00
		JSR JOYSTICK_GET
	:
	STA CONTR	;LOW
	STX CONTR+1	;HIGH

	STARTBUTTON:
	LDA CONTR
	AND #$10
	BNE SELECTBUTTONNEXT
		LDA INVFLAGS
		ORA #$04	;START HELD (BIT 2)
		STA INVFLAGS
		JMP SELECTBUTTON
	SELECTBUTTONNEXT:
		LDA INVFLAGS
		AND #$FB	;EVERYTHING BUT BIT 2
		STA INVFLAGS
		
	SELECTBUTTON:
	LDA CONTR
	AND #$20
	BNE RIGHTARROWNEXT
		JSR SELHANDLER
		JMP RIGHTARROW
	RIGHTARROWNEXT:
		LDA #$00
		STA HELDSELFOR
	
	RIGHTARROW:
	LDA CONTR
	AND #%00000001	
	BNE LEFTARROWNEXT
		;RIGHT ARROW
		JSR GORIGHT
		JMP LEFTARROW
	LEFTARROWNEXT:
		LDA #$00
		STA BUTTONDELAY+9

	LEFTARROW:
	LDA CONTR
	AND #%00000010 	
	BNE DOWNARROWNEXT
		;LEFT ARROW
		JSR GOLEFT
		JMP DOWNARROW
	DOWNARROWNEXT:
		LDA #$00
		STA BUTTONDELAY+8
		
	DOWNARROW:
	LDA CONTR
	AND #%00000100	
	BNE UPARROWNEXT
		;DOWN ARROW
		JSR GODOWN
		JMP UPARROW
	UPARROWNEXT:
		LDA #$00
		STA BUTTONDELAY+11
		
	UPARROW:
	LDA CONTR
	AND #%00001000	
	BNE ABUTTONNEXT
		;UP ARROW
		JSR GOUP
		JMP ABUTTON
	ABUTTONNEXT:
		LDA #$00
		STA BUTTONDELAY+10
		
	ABUTTON:
	LDA CONTR+1
	AND #$80	
	BNE NOA
		;A
		JSR ABUTTONHANDLER
		JMP BBUTTON
	NOA:
		LDA #$00
		STA BUTTONDELAY
		STA MINEFLAGS
		
	BBUTTON:
	LDA CONTR
	AND #$80
	BNE XBUTTON
		;B
		JSR GOJUMP
	
	XBUTTON:
	LDA CONTR+1
	AND #$40
	BNE NOX
		;X
		JSR XBUTTONHANDLER
		JMP YBUTTON
	NOX:
		LDA #$00
		STA BUTTONDELAY+2	;X
	
	YBUTTON:
	LDA CONTR
	AND #$40
	BNE NOY
		;Y
		JSR INCREASECURSORZ
		JMP LBUTTON
	NOY:
		LDA #$00
		STA BUTTONDELAY+3	;Y
		
	LBUTTON:
	LDA CONTR+1
	AND #$20
	BNE NOL
		;L
		JSR ROTATECURSORLEFT
		JMP RBUTTON
	NOL:
		LDA #$00
		STA BUTTONDELAY+4	;L
		
	RBUTTON:
	LDA CONTR+1
	AND #$10
	BNE NOR
		;R
		JSR ROTATECURSORRIGHT
		JMP SELBUTTON
	NOR:
		LDA #$00
		STA BUTTONDELAY+5	;R
	
	SELBUTTON:
	
	
	ENDCONTR:
		LDA #$FF
		STA CONTR
		STA CONTR+1	;TURN ALL BUTTONS OFF
;]

;[	INVENTORY MANAGEMENT
	LDA INVFLAGS
	AND #$02
	BEQ :+
		JSR DRAWINVCURSORS
	:
;]

;[	PHYSICS CALLING
	;WILL SET MFLAG %01000000 IF MOVED
		LDA PLAYERCOR
		STA LASTPLAYERCOR
		LDA PLAYERCOR+1
		STA LASTPLAYERCOR+1
	JSR MOVEXY
		LDA PLAYERCOR
		CMP LASTPLAYERCOR
		BNE :+
		LDA PLAYERCOR+1
		CMP LASTPLAYERCOR+1
		BNE :+
			JMP :++	;IF SAME DON'T CARE ABOUT THIS BIT
		:
			LDA MFLAG
			ORA #%01000000	;6TH BIT
			STA MFLAG
		:
	;CHECK CURRENT Z AND LAST Z
	LDA CURRENTZ
	STA TMPZ
	JSR GRAVITY
	
	JSR SETPLAYERCORTOPLAYER	;PLACES THE NEW X, Y, AND Z FROM PLAYERCOR IN VRAM
	JSR SETFACING
	LDA CURRENTZ
	CMP TMPZ
	BEQ :+
		LDA MFLAG
		ORA #%01000000	;6TH BIT
		STA MFLAG
		JSR DRAWCOORDINATESONLAYER1
		JSR CLEAROVERLAY	;BECAUSE IT IS NO LONGER RELEVANT ON NEW Z
	:
	;IF MOVED, THEN RUN THESE SUBROUTINES:
	LDA MFLAG
	AND #%01000000
	BEQ NOMOVEMENT	;ONLY ON FRAMES THE PLAYER MOVES
		LDA CURRENTZ
		CMP #$0F
		BCS :+
			JSR DRAWPLAYEROVERLAYONLAYER1
		:
		JSR DRAWCURSORBLOCK	;DRAW THE CURRENTLY SELECTED CURSOR BLOCK
		JSR DRAWCOORDINATESONLAYER1
	NOMOVEMENT:
	LDA MFLAG
	AND #%10111111
	STA MFLAG
	;INSERT BETTER ROUTINE OF SENDING PLAYER COR BACK TO PLAYER
;]

;[	MFLAG PROCESSING
	;RMDLRTS -> R IS RERENDER, M IS MOVED, S IS SOMETHING, I FORGET WHAT, OTHER FOUR BITS PROCESSED HERE
	LDA MFLAG
	AND #$01	;CHECK LAST BIT ON
	BEQ :+
		;TMP
			JSR DRAWHITBIT
			;CHECK FOR HIT BOUNDRY
			;JSR CHECKHITBOUNDARY
		LDA MFLAG
		AND #$FE
		STA MFLAG	;TURN OFF LAST BIT
	:
	;CHECK LOADING FLAGS
	LDA MFLAG
	AND #%00000010	;GO TOP
	BEQ :+
			;tmp 
				jsr SAVECHUNK
		;MOVE PLAYERCOR TO BOTTOM RIGHT
		LDA PLAYERCOR
		CLC
		ADC #$3C	;64
		STA PLAYERCOR
		LDA PLAYERCOR+1
		CLC
		ADC #$2C	;48
		STA PLAYERCOR+1
			;SET WHEN LOADED
		;SHIFT
		JSR SHIFTCHUNKSDOWN
		LDA MFLAG
		AND #%11111101	;TURN OFF THIS BIT
		ORA #%10000000	;TURN ON TOP BIT
		STA MFLAG
	:
	LDA MFLAG
	AND #%00000100	;GO RIGHT
	BEQ :+
			;tmp 
				jsr SAVECHUNK
		;MOVE PLAYERCOR TO BOTTOM LEFT
		LDA PLAYERCOR
		SEC
		SBC #$3C	;64
		STA PLAYERCOR
		LDA PLAYERCOR+1
		CLC
		ADC #$2C	;48
		STA PLAYERCOR+1
			;SET WHEN LOADED
		;SHIFT
		JSR SHIFTCHUNKSLEFT
		LDA MFLAG
		AND #%11111011	;TURN OFF THIS BIT
		ORA #%10000000	;TURN ON TOP BIT
		STA MFLAG
	:
	LDA MFLAG
	AND #%00001000	;GO LEFT
	BEQ :+
			;tmp 
				jsr SAVECHUNK
		;MOVE PLAYERCOR TO BOTTOM LEFT
		LDA PLAYERCOR
		CLC
		ADC #$3C	;64
		STA PLAYERCOR
		LDA PLAYERCOR+1
		SEC
		SBC #$2C	;48
		STA PLAYERCOR+1
			;SET WHEN LOADED
		;SHIFT
		JSR SHIFTCHUNKSRIGHT
		LDA MFLAG
		AND #%11110111	;TURN OFF THIS BIT
		ORA #%10000000	;TURN ON TOP BIT
		STA MFLAG
	:
	LDA MFLAG
	AND #%00010000	;GO DOWN
	BEQ :+
			;tmp 
				jsr SAVECHUNK
		;MOVE PLAYERCOR TO BOTTOM LEFT
		LDA PLAYERCOR
		SEC
		SBC #$3C	;64
		STA PLAYERCOR
		LDA PLAYERCOR+1
		SEC
		SBC #$2C	;48
		STA PLAYERCOR+1
			;SET WHEN LOADED
		;SHIFT
		JSR SHIFTCHUNKSUP
		LDA MFLAG
		AND #%11101111	;TURN OFF THIS BIT
		ORA #%10000000	;TURN ON TOP BIT
		STA MFLAG
	:
	;CHECK OTHER FLAGS
;]

ENDVSYNCHANDLER:
	JMP (DEFAULTIRQVECTOR)
;]

;[	MOVEMENT AND OTHER BUTTON SUBROUTINES --------------------------------
MOVEXY:
;[	;MOVEMENT PROCESSING AT THE PLAYERCOR LEVEL
	;ELSE CHECK MOVING INTO BLOCK
	MOVEMENTX:
			LDA COMPASSPOINTER+4	;CENTER CHUNK
			STA RAMBANK	;SET TO CENTRAL CHUNK
	LDA CURRENTBLOCK
	STA TMPCURRENTBLOCK
	LDA CURRENTBLOCK+1
	STA TMPCURRENTBLOCK+1
	;ADD IN CURRENT X
	LDA PLAYERCOR
	STA TMPPLAYERCOR
	;ADD IN X
	LDA SPEEDBUFFER		;X
	CLC
	ADC PLAYERCOR
	STA PLAYERCOR
	;CLEAR SPEEDBUFFER
		LDA #$00
		STA SPEEDBUFFER
		;CHECK FOR CURRENTZ==0F
		LDA CURRENTZ
		CMP #$0F
		BNE :+	
			JMP MOVEMENTY	;IS ON THE TOP OF THE BLOCK
		:
	JSR CALCULATECURRENTBLOCK
	;TEST IF HITS SOLID BLOCK ABOVE CURRENT BLOCK (CURRENTBLOCK +1ABOVE)
		;GET CURRENTBLOCK VALUE:
		LDA CURRENTBLOCK
		CLC
		ADC #$01	;GET THE BLOCK ABOVE IT
		STA POINTER
		LDA CURRENTBLOCK+1
		ADC #$A0
		STA POINTER+1	;POINTING TO $A000 + CURRENTBLOCK
		LDY #$00
		LDA (POINTER), Y
		CMP #$00	;AIR
		BNE :+	
		;TEST ONE ABOVE THIS IF NEEDED
		LDA CURRENTZ
		CMP #$0E
		BEQ CHECKGAPBLOCK	;NO NEED FOR FURTHER TESTING
		LDY #$01
		LDA (POINTER), Y
		CMP #$00
		BNE :+
			CHECKGAPBLOCK:
			;AIR BLOCK MOVEMENT ALLOWED
			;NOW NEED TO TEST FOR PLAYERCOR+1 +1 BECAUSE OF GAP IN BLOCKS
				LDA PLAYERCOR+1
				STA TMPPLAYERCOR+1
				INC PLAYERCOR+1
				JSR CALCULATECURRENTBLOCK
				DEC PLAYERCOR+1	;UNDO INCREASE
					LDA CURRENTBLOCK
					CLC
					ADC #$01
					STA POINTER
					LDA CURRENTBLOCK+1
					ADC #$A0
					STA POINTER+1
					LDY #$00
					LDA (POINTER), Y
					CMP #$00	;IS AIR
					BNE :+
					;TEST ONE ABOVE IF NEEDED
					LDA CURRENTZ
					CMP #$0E
					BEQ MOVEMENTY	;NO NEED FOR FURTHER TESTING
					LDY #$01
					LDA (POINTER), Y
					CMP #$00
					BNE :+
				;ELSE UP ONE IS ALSO AIR, IS ALLOWED TO MOVE
				JMP MOVEMENTY
		:
		;IS SOLID THEN RETURN TO LAST PLAYERCOR AND REMOVE ALL SPEEDBUFFER[0-1]
			LDA TMPPLAYERCOR
			STA PLAYERCOR
			LDA #$00
			STA SPEEDBUFFER
			STA SPEEDBUFFER+1
		;ALSO RETURN TO LAST CURRENTBLOCK
			LDA TMPCURRENTBLOCK
			STA CURRENTBLOCK
			LDA TMPCURRENTBLOCK+1
			STA CURRENTBLOCK+1
	
	MOVEMENTY:
	LDA CURRENTBLOCK
	STA TMPCURRENTBLOCK
	LDA CURRENTBLOCK+1
	STA TMPCURRENTBLOCK+1
	;ADD IN CURRENT Y
	LDA PLAYERCOR+1
	STA TMPPLAYERCOR
	;ADD IN y
	LDA SPEEDBUFFER+2		;Y
	CLC
	ADC PLAYERCOR+1
	STA PLAYERCOR+1
	;CLEAR SPEEDBUFFER+2
		LDA #$00
		STA SPEEDBUFFER+2
		;CHECK FOR CURRENTZ==0F
		LDA CURRENTZ
		CMP #$0F
		BNE :+	
			JMP HERECOMESGRAVITY	;IS ON THE TOP OF THE BLOCK
		:
	JSR CALCULATECURRENTBLOCK
	;TEST IF HITS SOLID BLOCK ABOVE CURRENT BLOCK (CURRENTBLOCK +1ABOVE)
		;GET CURRENTBLOCK VALUE:
		LDA CURRENTBLOCK
		CLC
		ADC #$01	;GET THE BLOCK ABOVE IT
		STA POINTER
		LDA CURRENTBLOCK+1
		ADC #$A0
		STA POINTER+1	;POINTING TO $A000 + CURRENTBLOCK
		LDY #$00
		LDA (POINTER), Y
		CMP #$00	;AIR
		BNE :+	
			;AIR BLOCK MOVEMENT ALLOWED
			;NOW CHECK BLOCK ABOVE THAT
			LDA CURRENTZ
			CMP #$0E
			BEQ HERECOMESGRAVITY	;IS ON THE TOP OF THE $0E
			;ELSE TEST FOR ONE ABOVE
				LDY #$01
				LDA (POINTER), Y
				CMP #$00	;AIR
				BNE :+	
			JMP HERECOMESGRAVITY
		:
		;IS SOLID THEN RETURN TO LAST PLAYERCOR AND REMOVE ALL SPEEDBUFFER[0-1]
			LDA TMPPLAYERCOR
			STA PLAYERCOR+1
			LDA #$00
			STA SPEEDBUFFER+2
			STA SPEEDBUFFER+3
		;ALSO RETURN TO LAST CURRENTBLOCK
			LDA TMPCURRENTBLOCK
			STA CURRENTBLOCK
			LDA TMPCURRENTBLOCK+1
			STA CURRENTBLOCK+1
	
	HERECOMESGRAVITY:
	RTS
;]

GORIGHT:
;[	
	;START HELD
	LDA INVFLAGS
	AND #$04
	BNE GORIGHTINV
	;INVENTORY OPEN
	LDA INVFLAGS
	AND #$01
	BNE GORIGHTINV
	;NOT ALLOWED IN AIR
	LDA JUMP
	AND #$04	;CHECK INAIR AND JUMPING
	BEQ :+
		RTS
	:
	;SET SPEEDBUFFER-X
	LDA SPEEDBUFFER+1	;SUBPIXEL LEVEL
	CLC
	ADC SPEED+1			;SPEED SUBPIXEL LELVEL
	STA SPEEDBUFFER+1
	
	LDA SPEEDBUFFER		;PIXEL LEVEL
	ADC SPEED			;SPEED PIXEL LEVEL
	STA SPEEDBUFFER
	
	;SET FACING
	LDA #$0C	;FACE RIGHT
	STA FACINGBUFFER
	JMP ENDGORIGHT
	
	GORIGHTINV:
		LDA BUTTONDELAY+9
		BNE :++
			LDA CURRENTINV
			CMP #$24	;36
			BNE :+	;OTHERWISE THIS IS CUT TO RESULTS
				LDA #$27	;39
				STA CURRENTINV
				JMP :++
		:
		LDA CURRENTINV
		CLC
		ADC #$01
		AND #$07
		STA TMPX
		LDA CURRENTINV
		AND #$F8
		ORA TMPX
		STA CURRENTINV
		LDA INVFLAGS
		ORA #$02
		STA INVFLAGS
		:
		INC BUTTONDELAY+9
		LDA BUTTONDELAY+9
		CMP CURSORBUTTONDELAY
		BCC ENDGORIGHT
		LDA #$00
		STA BUTTONDELAY+9
	ENDGORIGHT:
	RTS
;]

GOLEFT:
;[		
	;START HELD
	LDA INVFLAGS
	AND #$04
	BNE GOLEFTINV
	;INVENTORY OPEN
	LDA INVFLAGS
	AND #$01
	BNE GOLEFTINV
	
	;NOT ALLOWED IN AIR
	LDA JUMP
	AND #$04	;CHECK INAIR AND JUMPING
	BEQ :+
		RTS
	:
	;SET SPEEDBUFFER-X
	LDA SPEEDBUFFER+1	;SUBPIXEL LEVEL
	SEC
	SBC SPEED+1			;SPEED SUBPIXEL LELVEL
	STA SPEEDBUFFER+1
	
	LDA SPEEDBUFFER		;PIXEL LEVEL
	SBC SPEED			;SPEED PIXEL LEVEL
	STA SPEEDBUFFER
	
	;SET FACING
	LDA #$08	;FACE LEFT
	STA FACINGBUFFER
	JMP ENDGOLEFT
	
	GOLEFTINV:
		LDA BUTTONDELAY+8
		BNE :++
			LDA CURRENTINV
			CMP #$25	;37
			BNE :+
				LDA #$22	;34
				STA CURRENTINV
				JMP :++
		:
		LDA CURRENTINV
		SEC
		SBC #$01
		AND #$07
		STA TMPX
		LDA CURRENTINV
		AND #$F8
		ORA TMPX
		STA CURRENTINV
		LDA INVFLAGS
		ORA #$02
		STA INVFLAGS
		:
		INC BUTTONDELAY+8
		LDA BUTTONDELAY+8
		CMP CURSORBUTTONDELAY
		BCC ENDGOLEFT
		LDA #$00
		STA BUTTONDELAY+8
	ENDGOLEFT:
	RTS
;]

GOUP:
;[
	;INVENTORY OPEN
	LDA INVFLAGS
	AND #$01
	BNE GOUPINV
	
	;NOT ALLOWED IN AIR
	LDA JUMP
	AND #$04	;CHECK INAIR AND JUMPING
	BEQ :+
		RTS
	:
	;SET SPEEDBUFFER-Y
	LDA SPEEDBUFFER+3	;SUBPIXEL LEVEL
	SEC
	SBC SPEED+1			;SPEED SUBPIXEL LELVEL
	STA SPEEDBUFFER+3
	
	LDA SPEEDBUFFER+2	;PIXEL LEVEL
	SBC SPEED			;SPEED PIXEL LEVEL
	STA SPEEDBUFFER+2
	
	;SET FACING
	LDA #$04	;FACE UP
	STA FACINGBUFFER
	JMP ENDGOUP
	
	GOUPINV:
		LDA BUTTONDELAY+10
		BNE :++
			LDA CURRENTINV
			CMP #$18	;24
			BCC NORMALGOUPINV
				SEC
				SBC #$18
				TAX
				LDA TOPROWINVTRANSFER, X
				JMP :+
		NORMALGOUPINV:
		LDA CURRENTINV
		CLC
		ADC #$08
		CMP #$28
		BCC :+
			SEC
			SBC #$28
		:
		STA CURRENTINV
		LDA INVFLAGS
		ORA #$02
		STA INVFLAGS
		:
		INC BUTTONDELAY+10
		LDA BUTTONDELAY+10
		CMP CURSORBUTTONDELAY
		BCC ENDGOUP
		LDA #$00
		STA BUTTONDELAY+10
	
	ENDGOUP:
	RTS
;]

GODOWN:
;[
	;INVENTORY OPEN
	LDA INVFLAGS
	AND #$01
	BNE GODOWNINV
	
	;NOT ALLOWED IN AIR
	LDA JUMP
	AND #$04	;CHECK INAIR AND JUMPING
	BEQ :+
		RTS
	:
	;SET SPEEDBUFFER-Y
	LDA SPEEDBUFFER+3	;SUBPIXEL LEVEL
	CLC
	ADC SPEED+1			;SPEED SUBPIXEL LELVEL
	STA SPEEDBUFFER+3
	
	LDA SPEEDBUFFER+2	;PIXEL LEVEL
	ADC SPEED			;SPEED PIXEL LEVEL
	STA SPEEDBUFFER+2
	
	;SET FACING
	LDA #$00	;FACE DOWN
	STA FACINGBUFFER
	JMP ENDGODOWN
	
	GODOWNINV:
		LDA BUTTONDELAY+11
		BNE :++
			LDA CURRENTINV
			CMP #$08
			BCS CHECKGOUPTOPROW
				TAX
				LDA BTMROWINVTRANSFER, X
				JMP :+
			CHECKGOUPTOPROW:
			CMP #$20	;32
			BCC NORMALGODOWNINV
				SEC
				SBC #$18
				TAX
				LDA BTMROWINVTRANSFER, X
				JMP :+
		NORMALGODOWNINV:
		LDA CURRENTINV
		SEC
		SBC #$08
		CMP #$F8
		BCC :+
			SEC
			SBC #$D8
		:
			STA CURRENTINV
		LDA INVFLAGS
		ORA #$02
		STA INVFLAGS
		:
		INC BUTTONDELAY+11
		LDA BUTTONDELAY+11
		CMP CURSORBUTTONDELAY
		BCC ENDGODOWN
		LDA #$00
		STA BUTTONDELAY+11
	
	ENDGODOWN:
	RTS
;]

GOJUMP:
;[	PROCESSING THE JUMP
	;INVENTORY OPEN
	LDA INVFLAGS
	AND #$01
	BNE ENDGOJUMP
	;SHOULD I ALLOW CONTINUOUS JUMPS?
	LDA INAIR
	AND #$01
	BNE ENDGOJUMP	;NO JUMPING IN AIR
	
	LDA JUMP
	AND #%00000010	;MASK ALL BUT JUMPING AND IN AIR BIT
	CMP #$02
	BEQ ENDGOJUMP
		;ELSE SET JUMP
		ORA #$03	;%11
		STA JUMP
		;INAIR: NXXSSSSA	;IN EIGHT PIXELS
		LDA #%10001111
		STA INAIR
		LDA #$00
		STA FALLHEIGHTRACKER
		STA FALLHEIGHTRACKER+1
	ENDGOJUMP: 
	RTS
;]

SETPLAYERCORTOPLAYER:	;SETS PLAYERCOR TO PLAYER+2, PLAYER+4
;[
	;FIND FROM SPEEDBUFFER
		;LDA SPEEDBUFFER		;X
		;CLC
		;ADC PLAYERCOR
		;STA PLAYERCOR
		;LDA SPEEDBUFFER+2	;Y
		;CLC
		;ADC PLAYERCOR+1
		;STA PLAYERCOR+1
		;LDA #$00
		;STA SPEEDBUFFER
		;STA SPEEDBUFFER+2	;RESET X AND Y SPEEDBUFFER
	
	;SET TO VRAM
	LDA PLAYERSPRITE
	CLC
	ADC #$02	;PLAYER+2
	STA ADDRL
	LDA PLAYERSPRITE+1
	STA ADDRM
	LDA #$21	;MOVE TWO BYTES PER STORE
	STA ADDRH
	LDA PLAYERCOR
	SEC
	SBC #$03
	STA DATA0
		STA PLAYERCORTMP
	LDA PLAYERCOR+1
	SEC
	SBC #$0B
	STA DATA0
		STA PLAYERCORTMP+1
		
	;SET OVERLAYSPRITE:
	LDA OVERSPRITE
		CLC
		ADC #$02
	STA ADDRL
	LDA OVERSPRITE+1
	STA ADDRM
	LDA PLAYERCORTMP
	STA DATA0
	LDA PLAYERCORTMP+1
	STA DATA0
		
	RTS
;]

SETFACING:	;FROM FACINGBUFFER
;[
	LDA FACINGBUFFER
	STA FACING
	LDA PLAYERSPRITE	;PLAYER+0
	STA ADDRL
	LDA PLAYERSPRITE+1
	STA ADDRM
	LDA #$01	;DON'T MOVE FROM POINT
	STA ADDRH
	LDA FACING
	CLC
	ADC PLAYERSPRITEOFFSET 
	STA DATA0
	;SET OVERLAY FACING
	LDA OVERSPRITE
	STA ADDRL
	LDA OVERSPRITE+1
	STA ADDRM
		LDA FACING
		CLC
		ADC OVERLAYSPRITEOFFSET
		STA DATA0
	
	RTS
;]

ROTATECURSORLEFT:
;[
	;INVENTORY OPEN
		LDA INVFLAGS
		AND #$01
		BNE ENDROTATECURSOR
	;
	LDA BUTTONDELAY+4
	BEQ :++	;IF 0 CONTINUE
		CLC
		ADC #$01
		CMP STANDARDBUTTONDELAY
		BNE :+
			LDA #$00
		:
			STA BUTTONDELAY+4
			RTS
	:
	LDA #$01
	STA BUTTONDELAY+4
	;ROTATE
	LDA CURSORBLOCK
	AND #%00001111
	SEC
	SBC #$01
	CMP #$F8
	BCC :+
		LDA #$08
	:
	STA TMPX
	LDA CURSORBLOCK
	AND #%11110000
	ORA TMPX
	STA CURSORBLOCK
	
	LDA MFLAG
	ORA #%01000000	;SET FLAG FOR RENDERING LAYER1 AND CURSOR SPRITE
	STA MFLAG
	RTS
;]

ROTATECURSORRIGHT:
;[
	;INVENTORY OPEN
		LDA INVFLAGS
		AND #$01
		BNE ENDROTATECURSOR
	;
	LDA BUTTONDELAY+5
	BEQ :++	;IF 0 CONTINUE
		CLC
		ADC #$01
		CMP STANDARDBUTTONDELAY
		BNE :+
			LDA #$00
		:
			STA BUTTONDELAY+5
			RTS
	:
	LDA #$01
	STA BUTTONDELAY+5
	;ROTATE
	LDA CURSORBLOCK
	AND #%00001111
	CLC
	ADC #$01
	CMP #$09
	BCC :+
		LDA #$00
	:
	STA TMPX
	LDA CURSORBLOCK
	AND #%11110000
	ORA TMPX
	STA CURSORBLOCK
	
	LDA MFLAG
	ORA #%01000000	;SET FLAG FOR RENDERING LAYER1 AND CURSOR SPRITE
	STA MFLAG
	ENDROTATECURSOR:
	RTS
;]

INCREASECURSORZ:
;[	INCREASE CURSORBLOCK 4TH AND 5TH BIT
	;INVENTORY OPEN
		LDA INVFLAGS
		AND #$01
		BNE ENDROTATECURSOR
	;
	LDA BUTTONDELAY+3
	BEQ :++	;IF 0 CONTINUE
		CLC
		ADC #$01
		CMP STANDARDBUTTONDELAY
		BNE :+
			LDA #$00
		:
			STA BUTTONDELAY+3
			RTS
	:
	LDA #$01
	STA BUTTONDELAY+3
	;INCREASE CURSOR Z:
	LDA CURSORBLOCK
	CLC
	ADC #%00010000
	STA CURSORBLOCK
	AND #%01000000	;CHECK TO SEE IF OVERFLOW
	BEQ :+	
		LDA CURSORBLOCK
		AND #$0F	;RETURN TOP FOUR BITS TO 0
		STA CURSORBLOCK
	:
	LDA MFLAG
	ORA #%01000000	;SET FLAG FOR RENDERING LAYER1 AND CURSOR SPRITE
	STA MFLAG
	RTS
;]

ABUTTONHANDLER:
;[
	;INVENTORY OPEN
		LDA INVFLAGS
		AND #$01
		BNE ABUTTONINV 
	; OVERWORLD A:
		LDA MINEFLAGS
		CMP #$80
		BCC ABUTTONPLACEBLOCK
			;ELSE CONTINUE TO MINEBLOCK
			JSR KEEPMINING
			JMP ENDABUTTONHANDLER
		ABUTTONPLACEBLOCK:
			AND #$40	;TEST IF A BUTTON HELD DOWN
			BNE ENDABUTTONHANDLER	;IF THE A BUTTON IS STILL HELD, DO NOT PLACE BLOCK
			JSR PLACEBLOCK	;WILL AUTOMATICALLY SET MINE BLOCK TIMERS IF ON A SOLID BLOCK
			JMP ENDABUTTONHANDLER
	
	ABUTTONINV:
	LDA BUTTONDELAY
	BEQ :++	;IF 0 CONTINUE
		CLC
		ADC #$01
		CMP LONGBUTTONDELAY
		BNE :+
			LDA #$00
		:
			STA BUTTONDELAY
			RTS
	:;A BUTTON INVENTORY HANDLING:
		INC BUTTONDELAY
		;SET OR SWAP CURSORS
		LDA INVFLAGS
		AND #$08
		BEQ :+
			JSR SWAPINVCURSOR
			JMP ENDABUTTONHANDLER
		:
			JSR CONFIRM2NDINVCURSOR
	ENDABUTTONHANDLER:
	RTS
;]

XBUTTONHANDLER:
;[
	LDA BUTTONDELAY+2
	BEQ :++	;IF 0 CONTINUE
		CLC
		ADC #$01
		CMP LONGBUTTONDELAY
		BNE :+
			LDA #$00
		:
			STA BUTTONDELAY+2
			RTS
	:;X BUTTON HANDLING:
	INC BUTTONDELAY+2
	
	LDA INVFLAGS
	AND #$01
	BNE INVOPENX
		JSR OPENINVENTORY	;INVFLAGS SET IN THIS SUBROUTINE
		JMP ENDXBUTTONHANDLER
	INVOPENX:
		JSR CLOSEINVENTORY	;INVFLAGS SET IN THIS SUBROUTINE
		
	ENDXBUTTONHANDLER:
	RTS
;]

SELHANDLER:
;[
	INC HELDSELFOR
	LDA HELDSELFOR
	CMP #$30
	BNE :+
			;tmp 
				jsr SAVECHUNK
		LDA RELOAD
		ORA #$01
		STA RELOAD
		LDA #$00
		STA SETFRAME
	:
	RTS
;]

;]

VRAMBUFFERTOVERA:
;[	COPY DATA FROM VRAMBUFFER TO LAERY 0 TILE MAP $0E000
		;TMP
		JSR DRAWBORDER
		;END TMP
	LDA #$00
	STA ADDRL
	LDA #$00
	STA ADDRM
	LDA #$10
	STA ADDRH	;POINTING TO $00000	

	LDA #<VRAMBUFFER			;LO
		CLC
		ADC #$C0
	STA POINTER
	LDA #>VRAMBUFFER			;HIGH
		ADC #$03 ;ADD IN $03C0 TO SKIP 6 LINES
	STA POINTER+1
	
	LDX #$00
	LDY #$00
	:
		LDA (POINTER), Y
		STA DATA0
		INY
		CPY #$A0	;160 PIXELS WIDTH
		BNE :-
			INX
			CPX #$68	;112 LINES
			BEQ ENDVRAMBUFFERTOVERA
		;ELSE INCREASE BY 160
		LDA ADDRL
		CLC
		ADC #$A0
		STA ADDRL
		LDA ADDRM
		ADC #$00
		STA ADDRM
		;AND INCREASE POINTER BY 160
		LDY #$00
		LDA POINTER
		CLC
		ADC #$A0
		STA POINTER
		LDA POINTER+1
		ADC #$00
		STA POINTER+1
		JMP :-
	
	ENDVRAMBUFFERTOVERA:
		;JSR QUICKBLACKLINES ;(FOR THE LEFT THE RIGHT), NOT IMPLEMENTED
	RTS
;]

DRAWBORDER:
;[	DRAWS THE BOUNDARY THAT THE PLAYER HITS TO LOAD NEW CHUNKS
	;BOUNDARY SIZE: E2, WITH E0 & E1 BEING THE LAST SINGLE BIT
	rts
	LDY #$00
	LDX #$00
	:
		LDA BOUNDARY, X
		STX TMPX
		STA FA
		LDA #$A0	;160
		STA FB
		JSR MULT
		LDX TMPX
		INX
		LDA BOUNDARY, X
		CLC
		ADC FA
		STA POINTER
		LDA FB
		ADC #$00
		STA POINTER+1
		LDA POINTER
		CLC
		ADC #<VRAMBUFFER
		STA POINTER
		LDA POINTER+1
		ADC #>VRAMBUFFER
		STA POINTER+1
		LDA #$0C
		STA (POINTER), Y
		
		INX
		CPX #$E2
		BNE :-
		
	LDX #$00	;BELOW
		;112-Y
	:
		LDA BOUNDARY, X
		STX TMPX
		STA FA
		LDA #$70
		SEC 
		SBC FA
		STA FA
		LDA #$A0	;160
		STA FB
		JSR MULT
		LDX TMPX
		INX
		LDA BOUNDARY, X
		CLC
		ADC FA
		STA POINTER
		LDA FB
		ADC #$00
		STA POINTER+1
		LDA POINTER
		CLC
		ADC #<VRAMBUFFER
		STA POINTER
		LDA POINTER+1
		ADC #>VRAMBUFFER
		STA POINTER+1
		LDA #$0C
		STA (POINTER), Y
		INX
		CPX #$E0
		BNE :-
	LDX #$00	;RIGHT
		;159-X
	:
		LDA BOUNDARY, X
		STX TMPX
		STA FA
		LDA #$A0	;160
		STA FB
		JSR MULT
		LDX TMPX
		INX
		LDA BOUNDARY, X
			STA TMPY
			LDA #$9F	;159
			SEC
			SBC TMPY
		CLC
		ADC FA
		STA POINTER
		LDA FB
		ADC #$00
		STA POINTER+1
		LDA POINTER
		CLC
		ADC #<VRAMBUFFER
		STA POINTER
		LDA POINTER+1
		ADC #>VRAMBUFFER
		STA POINTER+1
		LDA #$0C
		STA (POINTER), Y
		INX
		CPX #$E2
		BNE :-
	
	LDX #$00	;BOTTOM & RIGHT
	:
		LDA BOUNDARY, X
		STX TMPX
		STA FA
		LDA #$70
		SEC 
		SBC FA
		STA FA
		LDA #$A0	;160
		STA FB
		JSR MULT
		LDX TMPX
		INX
		LDA BOUNDARY, X
			STA TMPY
			LDA #$9F
			SEC
			SBC TMPY
		CLC
		ADC FA
		STA POINTER
		LDA FB
		ADC #$00
		STA POINTER+1
		LDA POINTER
		CLC
		ADC #<VRAMBUFFER
		STA POINTER
		LDA POINTER+1
		ADC #>VRAMBUFFER
		STA POINTER+1
		LDA #$0C
		STA (POINTER), Y
		INX
		CPX #$E2
		BNE :-
	ENDDRAWBORDER:
	JSR DRAWHITBIT
	RTS
;]

DRAWHITBIT:
;[	SHOW THE PLAYER'S HIT BIT
	rts
	LDA PLAYERCOR+1	;PLAYER'S HB Y
		CLC
		ADC #$01;TMP ADD 1 FOR CLARITY
	STA FA
	LDA #$A0	;* 160
	STA FB
	JSR MULT
	LDA FA
		ASL
		STA ADDRL
		LDA FB
		ROL	; * 2 FOR TOTAL * 320
		STA ADDRM
	LDA PLAYERCOR
	CLC
	ADC ADDRL
	STA ADDRL
	LDA ADDRM
	ADC #$00
	STA ADDRM
	LDA #$10
	STA ADDRH
	LDA #$0C	;RED
	STA DATA0
	RTS
	
;]

CHECKHITBOUNDARY:
;[	CHECK HITBIT (PLAYERCOR) AGANST THE BOUNDARY
	;IF HIT WILL SET A BIT IN MFLAG
	;PLAYERCOR IS X, Y
	;BOUNDARY IS  Y, X
	
	;MUST SUBTRACT SCREENYOFFSET FROM PLAYERCOR+1
	LDA PLAYERCOR
	STA CHECKPLAYERBOUND
	LDA PLAYERCOR+1
	CLC
	ADC SCREENYOFFSET
	STA CHECKPLAYERBOUND+1
	
	;CHECK FOR BOUNDRIES IN TOP LEFT
	LDA CHECKPLAYERBOUND+1
	SEC
	SBC #$01
	CMP BOUNDARY+224	;BOUNDARY, E0, THE LAST Y
	BCC :+
		JMP CHECKBOTTOMBORDER;TMP SHOULD SEND THIS TO THE NEXT Y
	:	;CHECK X
	LDA CHECKPLAYERBOUND
	SEC
	SBC #$01
	CMP BOUNDARY+3	;FURTHEST X
	BCC :+
		JMP TOPRIGHTCHECK;SEND TO CHECK TOP RIGHT
	:	;CHECK AGAINST VALUES IN TOP LEFT
		LDX #$00
		:
			LDA BOUNDARY, X	;BOUNDARY Y
			CMP CHECKPLAYERBOUND+1	;PLAYER Y
			BEQ :+
				INX
				INX
				CPX #$E2
				BNE :-
				JMP ENDCHECKHITBOUNDARY
			:	;IS EQUAL TO THE Y
				INX
				LDA BOUNDARY, X	;BOUNDARY X
				CMP CHECKPLAYERBOUND
				BEQ :+
				;ELSE SEND BACK
				INX
				CPX #$E2
				BNE :-
				JMP ENDCHECKHITBOUNDARY
			:	;X ALSO EQUAL
				LDA MFLAG
				ORA #%00000010	;SET TO GO UP
				STA MFLAG
				JMP ENDCHECKHITBOUNDARY
			
	TOPRIGHTCHECK:
		LDX #$00
		:
			LDA BOUNDARY, X	;BOUNDARY Y
			CMP CHECKPLAYERBOUND+1	;PLAYER Y
			BEQ :+
				INX
				INX
				CPX #$E2
				BNE :-
				JMP ENDCHECKHITBOUNDARY
			:	;IS EQUAL TO THE Y
				INX
				LDA BOUNDARY, X	;159- BOUNDARY X
					STA TMPCHECK
					LDA #$9F	;159
					SEC
					SBC TMPCHECK
				CMP CHECKPLAYERBOUND
				BEQ :+
				;ELSE SEND BACK
				INX
				CPX #$E2
				BNE :-
				JMP ENDCHECKHITBOUNDARY
			:	;X ALSO EQUAL
				LDA MFLAG
				ORA #%00000100	;SET TO GO RIGHT
				STA MFLAG
				JMP ENDCHECKHITBOUNDARY
	
	CHECKBOTTOMBORDER:
	;CHECK X
	LDA CHECKPLAYERBOUND
	SEC
	SBC #$01
	CMP BOUNDARY+3	;FURTHEST X
	BCC :+
		JMP BOTTOMRIGHTCHECK;SEND TO CHECK TOP RIGHT
	:	;CHECK AGAINST VALUES IN TOP LEFT
		LDX #$00
		:
			;112 -BOUNDARY Y
			LDA BOUNDARY, X	;BOUNDARY Y
				STA TMPCHECK
				LDA #$70
				SEC
				SBC TMPCHECK
			CMP CHECKPLAYERBOUND+1	;PLAYER Y
			BEQ :+
				INX
				INX
				CPX #$E0
				BNE :-
				JMP ENDCHECKHITBOUNDARY
			:	;IS EQUAL TO THE Y
				INX
				LDA BOUNDARY, X	;BOUNDARY X
				CMP CHECKPLAYERBOUND
				BEQ :+
				;ELSE SEND BACK
				INX
				CPX #$E0
				BNE :-
				JMP ENDCHECKHITBOUNDARY
			:	;X ALSO EQUAL
				LDA MFLAG
				ORA #%00001000	;SET TO GO LEFT
				STA MFLAG
				JMP ENDCHECKHITBOUNDARY
			
	BOTTOMRIGHTCHECK:
		LDX #$00
		:
			;112 -BOUNDARY Y
			LDA BOUNDARY, X	;BOUNDARY Y
				STA TMPCHECK
				LDA #$70
				SEC
				SBC TMPCHECK
			CMP CHECKPLAYERBOUND+1	;PLAYER Y
			BEQ :+
				INX
				INX
				CPX #$E0
				BNE :-
				JMP ENDCHECKHITBOUNDARY
			:	;IS EQUAL TO THE Y
				INX
				LDA BOUNDARY, X	;159- BOUNDARY X
					STA TMPCHECK
					LDA #$9F	;159
					SEC
					SBC TMPCHECK
				CMP CHECKPLAYERBOUND
				BEQ :+
				;ELSE SEND BACK
				INX
				CPX #$E0
				BNE :-
				JMP ENDCHECKHITBOUNDARY
			:	;X ALSO EQUAL
				LDA MFLAG
				ORA #%00010000	;SET TO GO DOWN
				STA MFLAG
				JMP ENDCHECKHITBOUNDARY
		
	ENDCHECKHITBOUNDARY:
	RTS
;]

LOADFILES:
;[	
	;BLOCKS-----------------------------------------------
	;SETLFS
	LDA #$01
	LDX #$08	;DRIVE 8, ON EMULATOR is host system files
	LDY #$00
	JSR SETLFS
	;SETNAM
	LDA #(OVERWRITE-FILENAME)	;LENGTH OF FILE NAME
	LDX #<FILENAME
	LDY #>FILENAME
	JSR SETNAM	
	;LOAD
	LDA #$00
	LDX #<VRAMBUFFER
	LDY #>VRAMBUFFER
	JSR LOAD
		;COPY THIS INTO RAM BANKS 1 & 2
		JSR LOADBLOCKSINTOBANKS12
	;ITEMS------------------------------------------------
	;SETLFS
	LDA #$01
	LDX #$08	;DRIVE 8, ON EMULATOR is host system files
	LDY #$00
	JSR SETLFS
	;SETNAM
	LDA #(MOBNAME-ITEMNAME)	;LENGTH OF FILE NAME
	LDX #<ITEMNAME
	LDY #>ITEMNAME
	JSR SETNAM	
	;LOAD
		LDA ITEMSBANK	;STORE IN ITEMSBANK
		STA RAMBANK
	LDA #$00
	LDX #$00
	LDY #$A0	;SET TO RAMBANK
	JSR LOAD
	;MOBS--------------------------------------------------
	;SETLFS
	LDA #$01
	LDX #$08	;DRIVE 8, ON EMULATOR is host system files
	LDY #$00
	JSR SETLFS
	;SETNAM
	LDA #(CRAFTSCIINAME-MOBNAME)	;LENGTH OF FILE NAME
	LDX #<MOBNAME
	LDY #>MOBNAME
	JSR SETNAM	
	;LOAD
	LDA #(^VRAMMOBS + 2)
	LDX #<VRAMMOBS
	LDY #>VRAMMOBS
	JSR LOAD
	;CUSTOM PALETTE---------------------------------------
	LDA #$01
	LDX #$08	;DRIVE 8, ON EMULATOR is host system files
	LDY #$00
	JSR SETLFS
	;SETNAM
	LDA #(ITEMNAME-PALNAME)	;LENGTH OF FILE NAME
	LDX #<PALNAME
	LDY #>PALNAME
	JSR SETNAM	
	;LOAD
	LDA #(^VRAMPALAT + 2)
	LDX #<VRAMPALAT
	LDY #>VRAMPALAT
	JSR LOAD
	;CRAFTSCII:-------------------------------------------
	LDA #$01
	LDX #$08	;DRIVE 8, ON EMULATOR is host system files
	LDY #$00
	JSR SETLFS
	;SETNAM
	LDA #(QUICKTABLENAME-CRAFTSCIINAME)	;LENGTH OF FILE NAME
	LDX #<CRAFTSCIINAME
	LDY #>CRAFTSCIINAME
	JSR SETNAM	
	;LOAD
		LDA CRAFTSCIIBANK	;STORE IN CRAFTSCIIBANK
		STA RAMBANK
	LDA #$00
	LDX #$00
	LDY #$A0	;SET TO RAMBANK
	JSR LOAD
	;QUICKTABLE:-------------------------------------------
	LDA #$01
	LDX #$08	;DRIVE 8, ON EMULATOR is host system files
	LDY #$00
	JSR SETLFS
	;SETNAM
	LDA #(INFOTABLENAME-QUICKTABLENAME)	;LENGTH OF FILE NAME
	LDX #<QUICKTABLENAME
	LDY #>QUICKTABLENAME
	JSR SETNAM	
	;LOAD
		LDA QUICKTABLEBANK	;STORE IN CRAFTSCIIBANK
		STA RAMBANK
	LDA #$00
	LDX #$00
	LDY #$A0	;SET TO RAMBANK
	JSR LOAD
	;INFOTABLE:-------------------------------------------
	LDA #$01
	LDX #$08	;DRIVE 8, ON EMULATOR is host system files
	LDY #$00
	JSR SETLFS
	;SETNAM
	LDA #(TITLEFILENAME-INFOTABLENAME)	;LENGTH OF FILE NAME
	LDX #<INFOTABLENAME
	LDY #>INFOTABLENAME
	JSR SETNAM	
	;LOAD
		LDA INFOTABLEBANK	;STORE IN CRAFTSCIIBANK
		STA RAMBANK
	LDA #$00
	LDX #$00
	LDY #$A0	;SET TO RAMBANK
	JSR LOAD
	RTS
;]

LOADTITLETOVRAM:
;[ LOADS TITLE FROM FILE TO VRAM LAYER 0
	;CUSTOM PALETTE---------------------------------------
	LDA #$01
	LDX #$08	;DRIVE 8, ON EMULATOR is host system files
	LDY #$00
	JSR SETLFS
	;SETNAM
	LDA #(TMPEND-TITLEFILENAME)	;LENGTH OF FILE NAME
	LDX #<TITLEFILENAME
	LDY #>TITLEFILENAME
	JSR SETNAM	
	;LOAD
	LDA #(^VRAMTITLE + 2)
	LDX #<VRAMTITLE
	LDY #>VRAMTITLE
	JSR LOAD
;]

LOADBLOCKSINTOBANKS12:
;[
	LDA #<VRAMBUFFER
	STA POINTER
	LDA #>VRAMBUFFER	;POINT TO VRAMBUFFER
	STA POINTER+1
	LDA #$00
	STA POINTER2
	LDA #$A0
	STA POINTER2+1		;POINT TO $A000
	;SET RAMBANK[1]
	LDA #$01
	STA RAMBANK
	LDX #$00
	LDY #$00
	:
		LDA (POINTER), Y
		STA (POINTER2), Y
		INY
		CPY #$00
		BNE :-
		INC POINTER+1
		INC POINTER2+1
		INX
		CPX #$20
		BNE :-
		
	LDA #$02
	STA RAMBANK			;SET TO RAMBANK[2]
	LDA #$00
	STA POINTER2
	LDA #$A0
	STA POINTER2+1		;POINT TO $A000
	LDX #$00
	LDY #$00
	:
		LDA (POINTER), Y
		STA (POINTER2), Y
		INY
		CPY #$00
		BNE :-
		INC POINTER+1
		INC POINTER2+1
		INX
		CPX #$20
		BNE :-
	RTS
;]

CLEARVERAANDBUFFER:
;[ CLEAR THE TILE MAP IN VERA AND BUFFER
	LDA #$00
	STA ADDRL
	LDA #$00
	STA ADDRM
	LDA #%00010000
	STA ADDRH
	
	LDA #$00
	STA TMPX
	LOOP9600:
		LDX #$00
		LDY #$00
		LDA #$00
		:
			STA DATA0
			INX
			CPX #$00
			BNE :-
			INY
			CPY #$97	;97 INSTEAD OF 96 BECAUSE I NEED TO CLEAR FROM 0 TO 12E00 FOR SPACE REASONS
			BNE :-	;RAN TWICE TO CLEAR LAYER 0 & 1
		INC TMPX
		LDA TMPX
		CMP #$02
		BNE LOOP9600
	
	;BUFFER CLEAR	
	LDA #<VRAMBUFFER			;LO	
	STA VBUFFPOINTER
	LDA #>VRAMBUFFER			;HIGH
	STA VBUFFPOINTER+1
	
	LDX #$00
	LDY #$00
	LDA #$00
	:
		STA (VBUFFPOINTER), Y
		INY
		CPY #$00
		BNE :-
		INC VBUFFPOINTER+1
		INX
		CPX #$4B	;$9600 BYTES TOTAL
		BNE :-
	RTS
;]

LOADCHUNK:
;[	A = BANK TO LOAD CHUNK TO;	X-Y = CHUNKBCDX-CHUNKBCDY
	STA RAMBANK	;SET RAM BANK
		;0000_0000_0000_0000	READ LIKE ENGLISH TEXT
	LDA CHUNKBCDX
	AND #$F0	;SAVE FIRST FOUR BITS
		LSR
		LSR
		LSR
		LSR		;SHIFT TO LOWER
	CLC
	ADC TEXTOFFSET	;TO TEXT
	STA CHUNKX
	LDA CHUNKBCDX
	AND #$0F	;SAVE LAST FOUR BITS
	CLC
	ADC TEXTOFFSET	;TO TEXT
	STA CHUNKX+1
	LDA CHUNKBCDX+1
	AND #$F0	;SAVE FIRST FOUR BITS
		LSR
		LSR
		LSR
		LSR		;SHIFT TO LOWER
	CLC
	ADC TEXTOFFSET	;TO TEXT
	STA CHUNKX+2
	LDA CHUNKBCDX+1
	AND #$0F	;SAVE LAST FOUR BITS
	CLC
	ADC TEXTOFFSET	;TO TEXT
	STA CHUNKX+3
	
	LDA CHUNKBCDY
	AND #$F0	;SAVE FIRST FOUR BITS
		LSR
		LSR
		LSR
		LSR		;SHIFT TO LOWER
	CLC
	ADC TEXTOFFSET	;TO TEXT
	STA CHUNKY
	LDA CHUNKBCDY
	AND #$0F	;SAVE LAST FOUR BITS
	CLC
	ADC TEXTOFFSET	;TO TEXT
	STA CHUNKY+1
	LDA CHUNKBCDY+1
	AND #$F0	;SAVE FIRST FOUR BITS
		LSR
		LSR
		LSR
		LSR		;SHIFT TO LOWER
	CLC
	ADC TEXTOFFSET	;TO TEXT
	STA CHUNKY+2
	LDA CHUNKBCDY+1
	AND #$0F	;SAVE LAST FOUR BITS
	CLC
	ADC TEXTOFFSET	;TO TEXT
	STA CHUNKY+3
	
	;SETLFS
	LDA #$01
	LDX #$08	;DRIVE 8, ON EMULATOR is host system files
	LDY #$00
	JSR SETLFS
	;SETNAM
	LDA #(ENDCHUNKNAME-FILEFOLDER)	;LENGTH OF FILE NAME
	LDX #<FILEFOLDER
	LDY #>FILEFOLDER
	JSR SETNAM	
	;LOAD
	LDA #$00
	LDX #$00
	LDY #$A0	;RAM BANK @$A000
	JSR LOAD
	CMP #$00
	BEQ :+
		;ERROR IN LOADING FILE, GENERATE NEW CHUNK
		STA LOADINGERROR
		JSR GENERATECHUNK
	:
	RTS
;]

LOADINITIALCHUNKS:
;[ LOADS 9 CHUNKS BASED OFF OF THE GLOBALCOMPASS
	;LOAD 9 CHUNKS INTO THE CHUNKBASE - CHUNKBASE+8 RAM BANKS
	;SED	;TURN ON DECIMAL MODE

	LDA GLOBALCOMPASS+1
	SEC
	SBC #$01
	STA COMPASSTMP+1
	LDA GLOBALCOMPASS
	SBC #$00
	STA COMPASSTMP
	
	LDA GLOBALCOMPASS+3
	SEC
	SBC #$01
	STA COMPASSTMP+3
	LDA GLOBALCOMPASS+2
	SBC #$00
	STA COMPASSTMP+2
	
	;SET INITIAL COMPASSPOINTERS
	LDA CHUNKBASE
	LDX #$00
	:
		STA COMPASSPOINTER, X
		CLC
		ADC #$01
		INX
		CPX #$09
		BNE :-
		
	
	LDY #$00	;ITERATION
	STY TMPY
	STY TMPX
	:
		LDX #$00
		COPYCOMPASS:
			LDA COMPASSTMP, X
			STA CHUNKBCDX, X
			INX
			CPX #$04
			BNE COPYCOMPASS
		;SAVE VARIABLES:
			STA COMPASSTMPSTORE
			STX COMPASSTMPSTORE+1
			STY COMPASSTMPSTORE+2
			;CLD	;TURN OFF DEC
		;COPY CHUNK:
			LDX TMPX
			INC TMPX
			LDA COMPASSPOINTER, X
			JSR LOADCHUNK
		;LOAD VARIABLES
			;SED	;TURN ON DEC
			LDA COMPASSTMPSTORE
			LDX COMPASSTMPSTORE+1
			LDY COMPASSTMPSTORE+2
		;INCREASE X EVERY INTERVAL, EVERY THREE SUBTRACT 2
		;INCREASE Y EVERY 3
		INY
		CPY #$03
		BEQ CHECKENDCHUNKLOAD
			LDA COMPASSTMP+1
			CLC
			ADC #$01
			STA COMPASSTMP+1
			LDA COMPASSTMP
			ADC #$00
			STA COMPASSTMP
			JMP :-
		
	CHECKENDCHUNKLOAD:
		LDY #$00
		INC TMPY
		LDA TMPY
		CMP #$03
		BEQ ENDCHUNKLOAD
			;ELSE SUBTRACT 2 AND ADD ONE Y
			LDA COMPASSTMP+1
			SEC
			SBC #$02
			STA COMPASSTMP+1
			LDA COMPASSTMP
			SBC #$00
			STA COMPASSTMP
			
			CLC	;Y++
			LDA COMPASSTMP+3
			ADC #$01
			STA COMPASSTMP+3
			LDA COMPASSTMP+2
			ADC #$00
			STA COMPASSTMP+2
		JMP :-
		
	ENDCHUNKLOAD:
	RTS
;]

;[	SHIFTING SUBROUTINES
SHIFTCHUNKSLEFT:
;[	COPY 6 RIGHT CHUNKS TO 6 LEFT SLOTS (COMPASSPOINTER) & LOAD IN 3 NEW CHUNKS
	;SAVE THREE SLOTS TO BE RELOADED
	LDA COMPASSPOINTER
		STA OLDCHUNKCOMPASS
	LDA COMPASSPOINTER+3
		STA OLDCHUNKCOMPASS+1
	LDA COMPASSPOINTER+6
		STA OLDCHUNKCOMPASS+2
	
	;SHIFT OVER
	LDA COMPASSPOINTER+1
	STA COMPASSPOINTER
	LDA COMPASSPOINTER+2
	STA COMPASSPOINTER+1
	
	LDA COMPASSPOINTER+4
	STA COMPASSPOINTER+3
	LDA COMPASSPOINTER+5
	STA COMPASSPOINTER+4
	
	LDA COMPASSPOINTER+7
	STA COMPASSPOINTER+6
	LDA COMPASSPOINTER+8
	STA COMPASSPOINTER+7
	
	LDA OLDCHUNKCOMPASS
	STA COMPASSPOINTER+2
	LDA OLDCHUNKCOMPASS+1
	STA COMPASSPOINTER+5
	LDA OLDCHUNKCOMPASS+2
	STA COMPASSPOINTER+8
	
	;INCREASE GLOBALCOMPASS
	;SED	;TURN ON DECIMAL MODE
		LDA GLOBALCOMPASS+1
		CLC
		ADC #$01
		STA GLOBALCOMPASS+1
		LDA GLOBALCOMPASS
		ADC #$00
		STA GLOBALCOMPASS
	
	;LOAD 3 NEW RIGHT HAND CHUNKS
	;PRESET COMPASS X
		LDA GLOBALCOMPASS+1
		CLC
		ADC #$01
		STA COMPASSTMP+1
		LDA GLOBALCOMPASS
		ADC #$00
		STA COMPASSTMP
	;CLD	;TURN OFF DECIMAL MODE
	JSR LOADCOLUMNCHUNKS
	
	RTS
;]

SHIFTCHUNKSRIGHT:
;[	COPY 6 LEFT CHUNKS TO 6 RIGHT SLOTS (COMPASSPOINTER) & LOAD IN 3 NEW CHUNKS
	;SAVE THREE SLOTS TO BE RELOADED
	LDA COMPASSPOINTER+2
		STA OLDCHUNKCOMPASS
	LDA COMPASSPOINTER+5
		STA OLDCHUNKCOMPASS+1
	LDA COMPASSPOINTER+8
		STA OLDCHUNKCOMPASS+2
	
	;SHIFT OVER
	LDA COMPASSPOINTER+1
	STA COMPASSPOINTER+2
	LDA COMPASSPOINTER
	STA COMPASSPOINTER+1
	
	LDA COMPASSPOINTER+4
	STA COMPASSPOINTER+5
	LDA COMPASSPOINTER+3
	STA COMPASSPOINTER+4
	
	LDA COMPASSPOINTER+7
	STA COMPASSPOINTER+8
	LDA COMPASSPOINTER+6
	STA COMPASSPOINTER+7
	
	LDA OLDCHUNKCOMPASS
	STA COMPASSPOINTER
	LDA OLDCHUNKCOMPASS+1
	STA COMPASSPOINTER+3
	LDA OLDCHUNKCOMPASS+2
	STA COMPASSPOINTER+6
	
	;DECREASE GLOBALCOMPASS
	;SED	;TURN ON DECIMAL MODE
		LDA GLOBALCOMPASS+1
		SEC
		SBC #$01
		STA GLOBALCOMPASS+1
		LDA GLOBALCOMPASS
		SBC #$00
		STA GLOBALCOMPASS
	
	
	;LOAD 3 NEW LEFT HAND CHUNKS
	;PRESET COMPASS X
		LDA GLOBALCOMPASS+1
		SEC
		SBC #$01
		STA COMPASSTMP+1
		LDA GLOBALCOMPASS
		SBC #$00
		STA COMPASSTMP
	;CLD	;TURN OFF DECIMAL MODE
	JSR LOADCOLUMNCHUNKS
	
	RTS
;]

SHIFTCHUNKSDOWN:
;[	COPY 6 TOP CHUNKS TO 6 BOTTOM SLOTS (COMPASSPOINTER) & LOAD IN 3 NEW CHUNKS
	;SAVE THREE SLOTS TO BE RELOADED
	LDA COMPASSPOINTER+6
		STA OLDCHUNKCOMPASS
	LDA COMPASSPOINTER+7
		STA OLDCHUNKCOMPASS+1
	LDA COMPASSPOINTER+8
		STA OLDCHUNKCOMPASS+2
	
	;SHIFT OVER
	LDA COMPASSPOINTER+3
	STA COMPASSPOINTER+6
	LDA COMPASSPOINTER
	STA COMPASSPOINTER+3
	
	LDA COMPASSPOINTER+4
	STA COMPASSPOINTER+7
	LDA COMPASSPOINTER+1
	STA COMPASSPOINTER+4
	
	LDA COMPASSPOINTER+5
	STA COMPASSPOINTER+8
	LDA COMPASSPOINTER+2
	STA COMPASSPOINTER+5
	
	LDA OLDCHUNKCOMPASS
	STA COMPASSPOINTER
	LDA OLDCHUNKCOMPASS+1
	STA COMPASSPOINTER+1
	LDA OLDCHUNKCOMPASS+2
	STA COMPASSPOINTER+2
	
	;DECREASE GLOBALCOMPASS+2
	;SED	;TURN ON DECIMAL MODE
		LDA GLOBALCOMPASS+3
		SEC
		SBC #$01
		STA GLOBALCOMPASS+3
		LDA GLOBALCOMPASS+2
		SBC #$00
		STA GLOBALCOMPASS+2
	
	;LOAD 3 NEW RIGHT HAND CHUNKS
	;PRESET COMPASS Y
		LDA GLOBALCOMPASS+3
		SEC
		SBC #$01
		STA COMPASSTMP+3
		LDA GLOBALCOMPASS+2
		SBC #$00
		STA COMPASSTMP+2
	;CLD	;TURN OFF DECIMAL MODE
	JSR LOADROWCHUNKS
	
	RTS
;]

SHIFTCHUNKSUP:
;[	COPY 6 BOTTOM CHUNKS TO 6 TOP SLOTS (COMPASSPOINTER) & LOAD IN 3 NEW CHUNKS
	;SAVE THREE SLOTS TO BE RELOADED
	LDA COMPASSPOINTER
		STA OLDCHUNKCOMPASS
	LDA COMPASSPOINTER+1
		STA OLDCHUNKCOMPASS+1
	LDA COMPASSPOINTER+2
		STA OLDCHUNKCOMPASS+2
	
	;SHIFT OVER
	LDA COMPASSPOINTER+3
	STA COMPASSPOINTER
	LDA COMPASSPOINTER+6
	STA COMPASSPOINTER+3
	
	LDA COMPASSPOINTER+4
	STA COMPASSPOINTER+1
	LDA COMPASSPOINTER+7
	STA COMPASSPOINTER+4
	
	LDA COMPASSPOINTER+5
	STA COMPASSPOINTER+2
	LDA COMPASSPOINTER+8
	STA COMPASSPOINTER+5
	
	LDA OLDCHUNKCOMPASS
	STA COMPASSPOINTER+6
	LDA OLDCHUNKCOMPASS+1
	STA COMPASSPOINTER+7
	LDA OLDCHUNKCOMPASS+2
	STA COMPASSPOINTER+8
	
	;INCREASE GLOBALCOMPASS+2
	;SED	;TURN ON DECIMAL MODE
		LDA GLOBALCOMPASS+3
		CLC
		ADC #$01
		STA GLOBALCOMPASS+3
		LDA GLOBALCOMPASS+2
		ADC #$00
		STA GLOBALCOMPASS+2
	
	;LOAD 3 NEW RIGHT HAND CHUNKS
	;PRESET COMPASS Y
		LDA GLOBALCOMPASS+3
		CLC
		ADC #$01
		STA COMPASSTMP+3
		LDA GLOBALCOMPASS+2
		ADC #$00
		STA COMPASSTMP+2
	;CLD	;TURN OFF DECIMAL MODE
	JSR LOADROWCHUNKS
	
	RTS
;]

LOADCOLUMNCHUNKS:
;[ LOADS 3 CHUNKS ON RIGHT HAND SIDE BASED OFF OF THE GLOBALCOMPASS INTO OLDCHUNKCOMPASS
	;COMPASS X SET BEFOREHAND
	;LOAD 9 CHUNKS INTO THE CHUNKBASE - CHUNKBASE+8 RAM BANKS
	;SED	;TURN ON DECIMAL MODE

	;COMPASSX
	
	LDA GLOBALCOMPASS+3
	SEC
	SBC #$01
	STA COMPASSTMP+3
	LDA GLOBALCOMPASS+2
	SBC #$00
	STA COMPASSTMP+2
	
	;SET INITIAL COMPASSPOINTERS	
	LDY #$00	;ITERATION
	STY TMPY
	STY TMPX
	:
		LDX #$00
		:
			LDA COMPASSTMP, X
			STA CHUNKBCDX, X
			INX
			CPX #$04
			BNE :-
		;SAVE VARIABLES:
			STA COMPASSTMPSTORE
			STX COMPASSTMPSTORE+1
			STY COMPASSTMPSTORE+2
			CLD	;TURN OFF DEC
		;COPY CHUNK:
			LDX TMPX
			INC TMPX
			LDA OLDCHUNKCOMPASS, X
			JSR LOADCHUNK
		;LOAD VARIABLES
			;SED	;TURN ON DEC
			LDA COMPASSTMPSTORE
			LDX COMPASSTMPSTORE+1
			LDY COMPASSTMPSTORE+2
		;INCREASE Y EVERY INTERVAL
	
		LDY #$00
		INC TMPY
		LDA TMPY
		CMP #$03
		BEQ :+
			CLC	;Y++
			LDA COMPASSTMP+3
			ADC #$01
			STA COMPASSTMP+3
			LDA COMPASSTMP+2
			ADC #$00
			STA COMPASSTMP+2
		JMP :--
		
:
;CLD	;TURN OFF DECIMAL MODE
RTS
;]
LOADROWCHUNKS:
;[ LOADS 9 CHUNKS BASED OFF OF THE GLOBALCOMPASS
	;LOAD 9 CHUNKS INTO THE CHUNKBASE - CHUNKBASE+8 RAM BANKS
	;SED	;TURN ON DECIMAL MODE
	LDA GLOBALCOMPASS+1
	SEC
	SBC #$01
	STA COMPASSTMP+1
	LDA GLOBALCOMPASS
	SBC #$00
	STA COMPASSTMP
	
	;COMPASSY PRESET		
	
	LDY #$00	;ITERATION
	STY TMPY
	STY TMPX
	:
		LDX #$00
		:
			LDA COMPASSTMP, X
			STA CHUNKBCDX, X
			INX
			CPX #$04
			BNE :-
		;SAVE VARIABLES:
			STA COMPASSTMPSTORE
			STX COMPASSTMPSTORE+1
			STY COMPASSTMPSTORE+2
			CLD	;TURN OFF DEC
		;COPY CHUNK:
			LDX TMPX
			INC TMPX
			LDA OLDCHUNKCOMPASS, X
			JSR LOADCHUNK
		;LOAD VARIABLES
			;SED	;TURN ON DEC
			LDA COMPASSTMPSTORE
			LDX COMPASSTMPSTORE+1
			LDY COMPASSTMPSTORE+2
		;INCREASE X EVERY INTERVAL, EVERY THREE SUBTRACT 2
		;INCREASE Y EVERY 3
		INY
		CPY #$03
		BEQ :+
			LDA COMPASSTMP+1
			CLC
			ADC #$01
			STA COMPASSTMP+1
			LDA COMPASSTMP
			ADC #$00
			STA COMPASSTMP
			JMP :--		
:
;CLD	;TURN OFF DECIMAL MODE
RTS
;]

;]

SAVECHUNK:
;[	OVERWRITES THE CENTRAL CHUNK FILE BASED ON CURRENT DATA
	;TURN OFF INTERFERENCE
	LDA #$00	;STOP GAME LOGIC PROCESSING
	STA SETFRAME
	
	;[ ;GET CHUNK NAME
		LDA GLOBALCOMPASS
		STA CHUNKBCDX
		LDA GLOBALCOMPASS+1
		STA CHUNKBCDX+1
		LDA GLOBALCOMPASS+2
		STA CHUNKBCDX+2
		LDA GLOBALCOMPASS+3
		STA CHUNKBCDX+3
		;0000_0000_0000_0000
		LDA CHUNKBCDX
		AND #$F0	;SAVE FIRST FOUR BITS
			LSR
			LSR
			LSR
			LSR		;SHIFT TO LOWER
		CLC
		ADC TEXTOFFSET	;TO TEXT
		STA CHUNKX
		LDA CHUNKBCDX
		AND #$0F	;SAVE LAST FOUR BITS
		CLC
		ADC TEXTOFFSET	;TO TEXT
		STA CHUNKX+1
		LDA CHUNKBCDX+1
		AND #$F0	;SAVE FIRST FOUR BITS
			LSR
			LSR
			LSR
			LSR		;SHIFT TO LOWER
		CLC
		ADC TEXTOFFSET	;TO TEXT
		STA CHUNKX+2
		LDA CHUNKBCDX+1
		AND #$0F	;SAVE LAST FOUR BITS
		CLC
		ADC TEXTOFFSET	;TO TEXT
		STA CHUNKX+3
		
		LDA CHUNKBCDY
		AND #$F0	;SAVE FIRST FOUR BITS
			LSR
			LSR
			LSR
			LSR		;SHIFT TO LOWER
		CLC
		ADC TEXTOFFSET	;TO TEXT
		STA CHUNKY
		LDA CHUNKBCDY
		AND #$0F	;SAVE LAST FOUR BITS
		CLC
		ADC TEXTOFFSET	;TO TEXT
		STA CHUNKY+1
		LDA CHUNKBCDY+1
		AND #$F0	;SAVE FIRST FOUR BITS
			LSR
			LSR
			LSR
			LSR		;SHIFT TO LOWER
		CLC
		ADC TEXTOFFSET	;TO TEXT
		STA CHUNKY+2
		LDA CHUNKBCDY+1
		AND #$0F	;SAVE LAST FOUR BITS
		CLC
		ADC TEXTOFFSET	;TO TEXT
		STA CHUNKY+3
	;]
	DEC 
	;EXPORT DATA TO FILE
		LDA COMPASSPOINTER+4
		STA RAMBANK	;SET PROPER RAMBANK
	JSR SAVECHUNKAS
	
	LDA #$01
	STA SETFRAME	;ALLOW FURTHER PROCESSESING
	
	RTS
;]

RESETRENDERCHUNKS:
;[  
	;jmp CLEARRENDERCHUNKS
	;LDX #$00
	;:
	;	TXA
	;	STA CHUNKSTORENDER, X
	;	INX
	;	CPX #$09
	;	BNE :-
	;THIS WAS THE OLD ORDINAL ORDER, BELOW IS NOW ISOMETRIC ORDER
	LDA #$02
	STA CHUNKSTORENDER
	LDA #$01
	STA CHUNKSTORENDER+1
	LDA #$05
	STA CHUNKSTORENDER+2
	LDA #$00
	STA CHUNKSTORENDER+3
	LDA #$04
	STA CHUNKSTORENDER+4
	LDA #$08
	STA CHUNKSTORENDER+5
	LDA #$03
	STA CHUNKSTORENDER+6
	LDA #$07
	STA CHUNKSTORENDER+7
	LDA #$06
	STA CHUNKSTORENDER+8
	RTS
;]
CLEARRENDERCHUNKS:
;[	SET CHUNKSTORENDER[0-9] TO #$FF
	LDX #$00
	LDA #$FF
	:
		STA CHUNKSTORENDER, X
		INX
		CPX #$09
		BNE :-
	RTS
;]

SETBOTTOMRENDERCHUNKS:
;[	;ONLY 3 CHUNKS TO RENDER
	JSR CLEARRENDERCHUNKS
	LDA #$04
	STA CHUNKSTORENDER
	LDA #$03
	STA CHUNKSTORENDER+1
	LDA #$07
	STA CHUNKSTORENDER+2
;]

RENDERCHUNKS:
;[	GOING THROUGH THE POINTERS AND DRAWING THE CHUNKS
	;CALCUATE EACH BLOCK'S POSITION ON THE MAP TO DRAW
	;DEFAULT COMPASSOFFSET 0, 0 SETS CENTER CHUNK AT X: 8, Y: 2	
	;RENDERING CHUNKS
	LDX #$00
	LOADTHISCHUNK:
		STX TMPRENDERX
		LDA CHUNKSTORENDER, X
		TAX
		CMP #$FF	;DO NOT RENDER THIS CHUNK
		BEQ LOADNEXTCHUNK
		;SET RAM BANK
		LDA COMPASSPOINTER, X
		STA RAMBANK	;SWITCH RAM BANK TO CURRENT CHUNK FROM POINTER
		;CALCULATE INITIAL STARTING BLOCK XY TO RENDER
		LDA CHUNKOFFSETX, X
			CLC
			ADC SCROLLOFFSET
		STA LOADPOSITION
		LDA CHUNKOFFSETY, X
			CLC
			ADC SCROLLOFFSET+1
		STA LOADPOSITION+1
		;GET RESTRICTIONS
		LDA SCREENRESTRICTION, X
		STA CURRENTRESTRICTION
		
		;RENDER BACK HALF OF CHUNK:
		STA CHUNKLOADINGSTORE
		STX CHUNKLOADINGSTORE+1
		STY CHUNKLOADINGSTORE+2
			JSR COPYCHUNKTOVRAMBUFFER
		LDA CHUNKLOADINGSTORE
		LDX CHUNKLOADINGSTORE+1
		LDY CHUNKLOADINGSTORE+2

LOADNEXTCHUNK:
	LDX TMPRENDERX
	INX
	CPX #$09
		;HEREKID
	BEQ :+
		JMP	LOADTHISCHUNK
	:

RTS
;]

COPYTILETOXYVRAMBUFFER:	;COPIES TILE IN A TO POSITION IN BUFFER @ X, Y (IN PIXELS
;USES VBUFFPOINTER & POINTER
;[	
	;CHECK IF BLANK:
		CMP #$00
		BNE :+
			RTS	;RETURN IF AIR
		:
	;ELSE DRAW
	STA RENDERTMPA
	STX RENDERTMPX
	STY RENDERTMPY
	LDA RAMBANK	;SAVE CURRENT CHUNK RAM BANK, BLOCK DATA STORED IN RAMBANK[1-2]
	STA RENDERTMPBANK
	
	;CHECK FOR BEYOND SCOPE
	LDA RENDERTMPX
	CMP #$A0	;160
	BCC :+
		JMP ENDCOPYTILETOXY
	:	;EVERYTHING NORMAL
	LDA RENDERTMPY
	CMP #$78	;129
	BCC :+
		JMP ENDCOPYTILETOXY
	:	;EVERYTHING NORMAL
	
	;CHECK RESTRICTIONS:
	
	LDA CURRENTRESTRICTION
	CMP #$00
	BEQ ENDRESTRICTIONS
	
	AND #$F0	;CHECKING X RESTRICTIONS
	CMP #$00
	BEQ NOXRESTRICTIONS
	CMP #$10	;ONLY LEFT SIDE
	BNE :+
		LDA #$50	;80
		CLC
		ADC SCROLLOFFSET
		STA RESTRICTTMP
		LDA RENDERTMPX
		CMP RESTRICTTMP	;80 + SCROLLOFFSET
		BCC NOXRESTRICTIONS
			JMP ENDCOPYTILETOXY
	:
	CMP #$20	;ONLY RIGHT SIDE
	BNE :+
		LDA #$50	;80
		SEC
		SBC SCROLLOFFSET
		STA RESTRICTTMP
		LDA RENDERTMPX
		CMP RESTRICTTMP	;80 - SCROLLOFFSET
		BCS NOXRESTRICTIONS
			JMP ENDCOPYTILETOXY
	:
	NOXRESTRICTIONS:	;SO CHECK Y RESTRICTIONS
	LDA CURRENTRESTRICTION
	AND #$0F	;CHECKIGN Y RESTRICTIONS
	CMP #$01	;ONLY TOP SIDE
	BNE :+
		LDA RENDERTMPY
		CMP #$78	;120
		BCC ENDRESTRICTIONS
			JMP ENDCOPYTILETOXY
	:
	CMP #$02	;ONLY BOTTOM SIDE
	BNE :+
		LDA RENDERTMPY
		CMP #$20	;32
		BCS ENDRESTRICTIONS
			JMP ENDCOPYTILETOXY
	:
	ENDRESTRICTIONS:
	
	;BUFFER CLEAR	(ONLY HERE FOR REFERENCE)
		;LDA #<VRAMBUFFER			;LO	
		;STA VBUFFPOINTER
		;LDA #>VRAMBUFFER			;HIGH
		;STA VBUFFPOINTER+1
	
	;FIND ON SCREEN COORDINATES: Y * 160 + X
	LDA RENDERTMPY
	STA FA
	LDA #$A0	;160 
	STA FB
	JSR MULT
	LDA FA
	CLC
	ADC RENDERTMPX
	STA VBUFFPOINTER
	LDA FB
	ADC #$00	;STARTS AT $00000
	STA VBUFFPOINTER+1
	;ADD IN VBUFFER ADDRESS
	LDA VBUFFPOINTER
	CLC
	ADC #<VRAMBUFFER
	STA VBUFFPOINTER
	LDA VBUFFPOINTER+1
	ADC #>VRAMBUFFER
	STA VBUFFPOINTER+1
	;LAST CHECK
	LDA #>VRAMBUFFER
	CLC
	ADC #$4B
	CMP VBUFFPOINTER+1
	BCS :+
		;2ND OUT OF BOUNDS CHECK
		JMP ENDCOPYTILETOXY
	:
	
	;SET BLOCK DATA LOCATION
	LDA RENDERTMPA
	STA FA
	LDA #$00
	STA FB
	LDX #$00
	:
		ASL FA
		ROL FB
		INX
		CPX #$06
		BNE :-	
	;OLD MULTIPLY * 64
		;STA FA
		;LDA #$40
		;STA FB
		;JSR MULT	;MULT BY 64
		;RESULTS SHOULD BE [0000-4000) ANYTHING >= 2000 TURNS ON RAMBANK[2] INSTEAD OF RAMBANK[1]
	LDA FB
	CMP #$20
	BCC :+
		;DECREASE FB BY 20
		LDA FB
		SEC
		SBC #$20
		STA FB
		LDA #$02
		JMP :++
	:
		LDA #$01
	:
		STA RAMBANK	;SET PROPER RAMBANK

	LDA FA
	STA POINTER
	LDA FB
	CLC
	ADC #$A0	;TO RAMBANK SECTION $A000
	STA POINTER+1
	;SET BLOCK WIDTH:
	LDA RENDERTMPX
	CMP #$98
	BCC :+
		LDA #$A0
		SEC
		SBC RENDERTMPX
		STA BLOCKWIDTH
		JMP :++
	:
		LDA #$08
		STA BLOCKWIDTH
	:
	;COPY BLOCK DATA
	LDX #$00
	LDY #$00
	COPYBLOCKLOOP:
		LDA (POINTER), Y
		CMP #$00
		BEQ :+
			STA (VBUFFPOINTER), Y
		:
		INY
		CPY BLOCKWIDTH
		BNE COPYBLOCKLOOP
		LDY #$00
		INX
		CPX #$08
		BEQ ENDCOPYTILETOXY
			;ELSE INCREASE VBUFFPOINTER BY 160
			LDA VBUFFPOINTER
			CLC
			ADC #$A0
			STA VBUFFPOINTER
			LDA VBUFFPOINTER+1
			ADC #$00
			STA VBUFFPOINTER+1
				;CHECK FOR OUT OF BOUNDS
				LDA VBUFFPOINTER+1
				CMP #>ENDVRAMBUFFER
				BCC :+
				LDA VBUFFPOINTER
				CMP #<ENDVRAMBUFFER
				BCC :+
					;ELSE OUT OF BOUNDS
					JMP ENDCOPYTILETOXY
			:
			;AND INCREASE POINTER BY 8
			LDA POINTER
			CLC
			ADC #$08
			STA POINTER
			LDA POINTER+1
			ADC #$00
			STA POINTER+1
			JMP COPYBLOCKLOOP
		
	ENDCOPYTILETOXY:
	;RETURN TO PROPER RAMBANK
	LDA RENDERTMPBANK
	STA RAMBANK
	RTS
;]

COPYCHUNKTOVRAMBUFFER:
;[	;FROM $A000 TO $AFFF
	;CHECK OUT OF BOUNDS:
	;LDA LOADPOSITION
	;LDA LOADPOSITION+1
	
	;FOR EACH BLOCK IN THE CHUNK, FIND THE X AND Y VALUES FOR IT ON SCREEN, AND THEN CALL COPYTILETOXYVRAMBUFFER
	
	LDA #$00
	STA POINTER2
	LDA #$A0
	STA POINTER2+1	;POINT TO RAMBANK
	
	LDA #$00
	STA CURRENTLINE	;KEEPS TRACK OF Y OFFSET
	STA TMPA		;COLUMN COUNTER
	
	LDX #$00
	STX TMPX	;0-16 FOR PER COLUMN
	LDY #$00
	STY TMPY	;COUNTER FOR INTERATION
	
	BLOCKRENDERLOOP:
		LDY TMPY
		LDA (POINTER2), Y	;GET BLOCK NUMBER
		STA FA
		
		LDA TMPA
		JSR GETQUICKOFFSET
		LDA STOREPOSITION
		CLC
		ADC LOADPOSITION
		TAX
		LDA STOREPOSITION+1
		CLC
		ADC LOADPOSITION+1
		SEC
		SBC CURRENTLINE
		TAY
		LDA FA
		JSR COPYTILETOXYVRAMBUFFER
		
		INC TMPY
		BNE :+
			INC POINTER2+1
		:
		
		LDA CURRENTLINE
		CLC
		ADC #$03
		STA CURRENTLINE

		INC TMPX
		LDA TMPX
		CMP #$10
		BNE BLOCKRENDERLOOP
			LDA #$00
			STA TMPX
			STA CURRENTLINE
			INC TMPA
			BNE BLOCKRENDERLOOP
		
	ENDDRAWTILES:
	RTS
;]

GETQUICKOFFSET:
;[	;RETURNS OFFSET OF BLOCKNUMBER [0-255] (IN TMPA) IN STOREPOSITION, STOREPOSITION+1
	;STORE CURRENTLY USED RAMBANK
	LDA RAMBANK
	STA RAMBANKTMP
	LDA QUICKTABLEBANK
	STA RAMBANK
	
	LDA TMPA
	ASL
	TAX
	BCS GETOFFSETLARGE
	GETOFFSETSMALL:
		LDA $B800, X
		STA STOREPOSITION
		LDA $B801, X
		STA STOREPOSITION+1
		JMP ENDGETQUICKOFFSET
	GETOFFSETLARGE:
		LDA $B900, X
		STA STOREPOSITION
		LDA $B901, X
		STA STOREPOSITION+1
		JMP ENDGETQUICKOFFSET
		
	ENDGETQUICKOFFSET:
		LDA RAMBANKTMP
		STA RAMBANK
	RTS
;]

;GENERATION SUBROUTINES
	;TMP
	GENBLOCKS: .BYTE $01, $0D, $10, $18, $1B, $81, $27, $29
	GENHERE: .BYTE $00
;[
GENERATECHUNK:
;[
	;TMP:
		JSR RNG
		AND #$07
		TAX
		LDA GENBLOCKS, X
		STA GENHERE
	;NORMAL:
	JSR SETHEIGHTTABLE
	LDA #$00
	STA POINTER
	LDA #$A0
	STA POINTER+1
	
	;GET SEED
	JSR RNG
	STA GENSEED
	
	LDX #$00	;BLOCK NUMBER IN COLUMN
	STX GENTMPX
	LDY #$00	;USED FOR STORING INTO POINTER
	STY GENTMPY
	GENLOOP:
		STX GENTMPX
		LDX GENSEED
		LDA HEIGHTTABLE, X
		;TMP
			LDA #$08	;SET HEIGHT
		STA GENTMPA
		LDX GENTMPX
		CPX GENTMPA	;COMPARE X AGAINST MAXHEIGHT
		BCC ADDBLOCK
			LDA #$00	;ADD AIR
			JMP STOREBLOCK
		ADDBLOCK:
			TXA
			ADC #$01
			;TMP
				LDA GENHERE	;DIRT
		STOREBLOCK:
		STA (POINTER), Y
		INY
		CPY #$00
		BNE :+
			INC POINTER+1
		:
		INX
		CPX #$10
		BNE GENLOOP
			;ELSE TRACK NUMBER OF COLUMNS
			LDX #$00
			INC GENSEED
			INC GENTMPY
			LDA GENTMPY
			CMP #$00
			BNE GENLOOP
			
			
	;	OLD GENERATOR
	;	LDA GENTMPX
	;	CMP HEIGHTTABLE, Y
	;	BCC NOTAIR
	;		LDA #$00	;AIR
	;		JMP ADDBLOCK
	;	NOTAIR:
	;		LDA #$01	;DIRT
	;	ADDBLOCK:
	;		STA (POINTER), Y
	;	INY
	;	CPY #$00
	;	BNE :-
	;		INC POINTER+1
	;		INX
	;		STX GENTMPX
	;		CPX #$10
	;		BNE :-
	;END GENERATE CHUNK
	JSR SAVECHUNKAS
	RTS
;]

SETHEIGHTTABLE:
;[
	LDX #$00
	LDA #$00
	HLOOP:
		LDA NOISETABLE, X
			LSR
			LSR
			LSR
			LSR		;FLOOR TO 4 BIT NUMBER
		CMP #$00
		BNE :+
			LDA #$01
		:
		STA HEIGHTTABLE, X
		INX
		CPX #$00
		BNE HLOOP
	RTS
;]

SAVECHUNKAS:		;AS CURRENT NAME IN CHUNKBCDX & CHUNKBCDY
;[
	;SETLFS
	LDA #$01	
	LDX #$08	;DRIVE 8, ON EMULATOR is host system files
	LDY #$00
	JSR SETLFS
	;SETNAM
		LDA #(ENDCHUNKNAME-OVERWRITE)	;LENGTH OF FILE NAME
		LDX #<OVERWRITE
		LDY #>OVERWRITE
	JSR SETNAM	
	;SAVE
	LDX #$00				;LO	LOCATION OF FILE TO SAVE (RAM BANK)
	LDY #$B0				;HIGH
	;END ADDRESS: LOWBYTE X, HIGHBYTE Y
	LDA #$00
	STA POINTER
	LDA #$A0
	STA POINTER+1
		
	LDA #POINTER		;MEMORY ADDRESS TO POINTER TO FILEBUFFER ON ZEROPAGE
	JSR SAVE
	;hey kid, this shouldn't be here all the time
	RTS
;]

;]

;PHYSICS ------------------------------------------------------------------------
;[
GRAVITY:
;[	CHANGES THE Z-MOMENTUM OF THE PLAYER, AND MOVES THEM ALONG, USES TMPX
	;INAIR: NXXSSSSA
		;N - NEGATIVE SPEED
		;S - SPEED IN EIGHT PIXELS
		;A - INAIR 1 YES, 0 NO
	;IF INAIR DROP DOWN AND CHECK IF LANDED ON BLOCK
	
	;IF ON GROUND:
	;CHECK IF CURRENT BLOCK IS SOLID
	;IF NOT SET INAIR AND ADD ZSPEED
	;IF SO RETURN
	LDA COMPASSPOINTER+4	;CENTER CHUNK
	STA RAMBANK	;SET TO CENTRAL CHUNK
	
	LDA JUMP
	AND #$01	;ONLY LAST BIT
	CMP #$01
	BCS :+	;IF JUMPING IMMEDEATLY GOTO THE GRAVITY
	
	LDA CURRENTZ
	CMP #$10	;LAYER 16 ABOVE THE BLOCKS
	BEQ :+
	LDA CURRENTZ
	CMP #$00	;ON BOTTOM OF WORLD
	BEQ NOTINAIR
	
	JSR CALCULATECURRENTBLOCK
	
	LDA CURRENTBLOCK
	STA POINTER
	LDA CURRENTBLOCK+1
	CLC
	ADC #$A0
	STA POINTER+1	;POINTING TO $A000 + CURRENTBLOCK
	
	
	LDY #$00
	LDA (POINTER), Y
	CMP #$00	;AIR
	BEQ :+	;IN AIR
		;CHECK BLOCK ABOVE, TO SEE IF IS [NOT] A SOLID BLOCK (IF SOLID THEN STILL IN AIR)
		LDA CURRENTZ
		CMP #$0F
		BEQ NOTINAIR
			LDY #$01
			LDA (POINTER), Y
			CMP #$00
			BNE :+
			;AND MUST CHECK ONE ABOVE THIS
			LDA CURRENTZ
			CMP #$0E
			BEQ NOTINAIR
				LDY #$02
				LDA (POINTER), Y
				CMP #$00
				BNE :+
		NOTINAIR:
		;ELSE NOT IN AIR
		LDA #$00
		STA FALLHEIGHTRACKER
		STA FALLHEIGHTRACKER+1
		STA INAIR
			LDA #$00
			STA JUMP
		RTS
	:
	;OTHERWISE SET INAIR
	LDA INAIR
	ORA #$01	;SET INAIR TO TRUE
	STA INAIR
		;ADD OR SUBTRACT SPEED
		LDA INAIR
		AND #$80
		BEQ :+
			LDA INAIR
			SEC
			SBC #$02	;SUB 1 FROM SPEED 
			STA INAIR
			AND #%00011110
			CMP #$00	;IF ALL 0
			BNE :++
			;ELSE JUMP OVER
			LDA INAIR
			AND #%01111111	;TURN OFF NEGATIVE
			STA INAIR
			;SET BIT NOT JUMPING UP ANYMORE
				LDA JUMP
				AND #%11111110	;CUT OUT JUMPING UP BIT
				STA JUMP
		:	;ADD ZSPEED
		LDA INAIR
		CLC
		ADC #$02	;ADD 1 TO SPEED
		STA INAIR
	:
	LSR	;GET RID OF SIGNAL A
	LSR
	LSR	;DIVIDE BY EIGHT FOR WHOLE PIXELS
	AND #%00000011	;MASK OUT EVERYTHING BUT SPEED IN WHOLE PIXELS
	STA TMPX
		;CHECK IF NEGATIVE (JUMPING UP)
		LDA INAIR
		AND #$80
		BEQ :+
		LDA TMPX
		CLC
		ADC FALLHEIGHTRACKER+1	;FOR NEGATIVE HEIGHT
		STA FALLHEIGHTRACKER+1
			CMP #$03
			BCC MOVEGY
			;ELSE MOVE Z UP 1
			SEC
			SBC #$03
			STA FALLHEIGHTRACKER+1	;TO KEEP ALIGNED
			INC CURRENTZ
			LDA CURRENTZ
			CMP #$11
			BNE MOVEGY
				LDA #$10
				STA CURRENTZ	;NO GOING OVER WORLD HEIGHT, EVEN THOUGH TECHNICALLY YES IT IS
			JMP MOVEGY
	:
	LDA TMPX
	CLC
	ADC FALLHEIGHTRACKER
	STA FALLHEIGHTRACKER
		CMP #$03
		BCC :+
			;ELSE MOVE DOWN 1 Z
			SEC
			SBC #$03
			STA FALLHEIGHTRACKER	;TO KEEP ALIGNED
			DEC CURRENTZ
			LDA CURRENTZ
			CMP #$FF
			BNE :+
				LDA #$00
				STA CURRENTZ	;NO FALLING THROUGH THE WORLD
		:
	
	MOVEGY:
		LDA TMPX
		CMP #$00
		BEQ ENDGRAVITY
			LDA INAIR
			AND #$80
			BEQ :+
			LDA PLAYERCOR+1
			SEC
			SBC TMPX
			JMP :++
		:
			LDA PLAYERCOR+1
			CLC
			ADC TMPX
		:
			STA PLAYERCOR+1
	
	ENDGRAVITY:
		;SET THIRD BIT OF JUMP BASED ON FALLHEIGHTRACKER
		LDA FALLHEIGHTRACKER
		CMP FALLHEIGHTRACKER+1
			BNE :+
			CMP #$00
			BNE :+
			LDA JUMP
			AND #%11111011
			STA JUMP
			JMP :++
		:	;IN THE AIR, NO MOVEMENT
			LDA JUMP
			ORA #%00000100
			STA JUMP
		:
	RTS
;]

CALCULATECURRENTBLOCK:
;[	;FROM PLAYERCOR, PLAYERCOR+1
	;FOR THE CURRENT LOCATION -> 
	;LOAD QUICKTABLEBANK
	;Y * 128 + X
	;FIND BLOCK#
	;BACKGROUND IS 34 + 51
		;SO IF IS $34 AND LINE ABOVE IS $51 THEN IS BACKGROUND
	LDA CURRENTZ
	CMP #$10	;ABOVE THE BLOCK IN THE AIR
	BNE :+	
		RTS
	:
	
	;STORE CURRENTLY USED RAMBANK
	LDA RAMBANK
	STA RAMBANKTMP
	
	LDA #$00
	STA CURRENTTMP
	
	;EDIT PLAYERCOR TO BE BASED ON TOPLAYER OFFSET
		;PLAYERCOR - 16
		;PLAYERCOR+1 - ((15 - CURRENTZ) * 3)
	LDA PLAYERCOR
	SEC
	SBC #$0F
	STA PLAYERCORTMP	;PLAYERCOR - 8 (CHUNK RENDERING OFFSET)
	LDA #$13
	SEC
	SBC CURRENTZ
	STA FA
	LDA #$03
	STA FB
	JSR MULT
	LDA PLAYERCOR+1
	SEC
	SBC FA
	;IF PLAYERCORTMP+1 > 48, PLAYERCORTMP+1 = 96 - PLAYERCORTMP+1
	CMP #$30	;< 48 WILL JUMP
	BCC :+	
		STA PLAYERCORTMP+1
			LDA #$01
			STA CURRENTTMP	;MARK THAT IS OVER THE SECOND HALF
		LDA #$5F
		SEC
		SBC PLAYERCORTMP+1
	:
	STA PLAYERCORTMP+1	;PLAYERCOR+1 - ((15 - CURRENTZ) * 3)
	
	;CHECK BLOCK NUMBER
	LDA #$00
	STA POINTER+1
	LDA PLAYERCORTMP+1
	STA POINTER
	LDX #$00
	:
		ASL POINTER
		ROL POINTER+1
		INX
		CPX #$07	;2^7
		BNE :-


	LDY #$00
	LDA QUICKTABLEBANK
	STA RAMBANK
	
	LDA CURRENTTMP
	CMP #$01
	BEQ :+
		LDA POINTER
		CLC
		ADC PLAYERCORTMP
		STA POINTER
		LDA POINTER+1
		ADC #$A0	;ADD IN $A0
		STA POINTER+1
		;CHECK
		LDA (POINTER), Y
		JMP :++
	:	;IS IN THE LOWER HALF, MUST SUBTRACT
		LDA POINTER
		SEC
		SBC PLAYERCORTMP
		STA POINTER
		LDA POINTER+1
		SBC #$00
		CLC
		ADC #$A0
		STA POINTER+1
		;CHECK AND CHANGE
		LDA (POINTER), Y
	:
	
	
	CMP #$34	;NULLBACKGROUND0
	BNE CHECK51
		;ELSE CHECK TO SEE IF ABOVE IS $51
		STA PLAYERCORTMP
		LDA POINTER
		SEC
		SBC #$80	; - 128
		STA POINTER
		LDA POINTER+1
		SBC #$00
		STA POINTER+1
		CMP #$FF
		BEQ ERRORBLOCK	;ON TOP ROW
		LDA (POINTER), Y
		CMP #$51
		BEQ ERRORBLOCK
		LDA PLAYERCORTMP	;RELOAD THE CORRECT BLOCK
		JMP ADDCURRENTZ
	CHECK51:
	CMP #$51
	BNE ADDCURRENTZ
		;ELSE CHECK TO SEE IF ABOVE IS $34
		STA PLAYERCORTMP
		LDA POINTER
		SEC
		SBC #$80	; - 128
		STA POINTER
		LDA POINTER+1
		SBC #$00
		STA POINTER+1
		CMP #$FF
		BEQ ERRORBLOCK	;ON TOP ROW
		LDA (POINTER), Y
		CMP #$34
		BEQ ERRORBLOCK
		LDA PLAYERCORTMP	;RELOAD THE CORRECT BLOCK
		;JMP ADDCURRENTZ	;IT'S RIGHT HERE
	
	ADDCURRENTZ:
	STA CURRENTBLOCK
	LDA CURRENTTMP
	CMP #$01
	BNE GETFULLZ
		LDA CURRENTBLOCK
		EOR #$FF	;BITWISE NOT, GET THE $FF - A VALUE
		STA CURRENTBLOCK	;FOR UNDERNEATH THE FIRST HALF
	GETFULLZ:	
		;CURRENT A = 0-255, RESULT SHOULD BE (A * 16) + CURRENTZ
	LDA #$00
	STA CURRENTBLOCK+1
	LDX #$00
	:
		ASL CURRENTBLOCK
		ROL CURRENTBLOCK+1
		INX
		CPX #$04
		BNE :-
	LDA CURRENTBLOCK
	CLC
	ADC CURRENTZ
	STA CURRENTBLOCK
	LDA CURRENTBLOCK+1
	ADC #$00
	STA CURRENTBLOCK+1	;FINISHED
	JMP ENDCALCULATECURRENTBLOCK
	
	ERRORBLOCK:
		LDA #$FF			;LAST BLOCK FOR NOW, WILL MAKE ERROR LATER
		STA CURRENTBLOCK
		LDA #$0F
			;HEY KID SHOULD ACTUALLY GET CORRECTED EDGE BLOCK AND SEND PLAYER THERE
		STA CURRENTBLOCK+1
			;MOVE INTO NEW BLOCK:
			;CALCULATE WHICH SIDE OF THE BLOCK THE PLAYER IS ON VIA CURRENT X / Y
				;CURRENTTMP SHOULD HOLD WHETHER IS ON TOP OR BELOW
			LDA CURRENTTMP
			CMP #$01
			BEQ :++	;LOWER CHUNKS
				LDA PLAYERCOR
				CMP #$50
				BCS :+
					;TOP LEFT (UP)
					LDA MFLAG
					ORA #%00000010	;MOVE INTO TOP SQUARE
					STA MFLAG
					JMP ENDCALCULATECURRENTBLOCK
				:
					;TOP RIGHT (RIGHT)
					LDA MFLAG
					ORA #%00000100
					STA MFLAG
					JMP ENDCALCULATECURRENTBLOCK
			:
				LDA PLAYERCOR
				CMP #$50
				BCS :+
					;BOTTOM LEFT (LEFT)
					LDA MFLAG
					ORA #%00001000
					STA MFLAG
					JMP ENDCALCULATECURRENTBLOCK
				:
					;BOTTOM RIGHT (DOWN)
					LDA MFLAG
					ORA #%00010000
					STA MFLAG
					JMP ENDCALCULATECURRENTBLOCK
	ENDCALCULATECURRENTBLOCK:
	;RESTORE CURRENTLY USED RAMBANK
	LDA RAMBANKTMP
	STA RAMBANK
	
	RTS
	
	;IF NO TO EVERYTHING, THEN TRY AND TRANSFER CHUNKS
	
;]

DRAWCURRENTBLOCK:	;NEEDS TO BE UPDATED TO CHECK FOR BLOCK RESIDUE ON DIFFERENT ZLEVELS
;[
	;THERE IS NO SIMPLE CALCULATION FOR THIS, IT MUST BE KEPT TRACK OF
	;LDA PLAYERCOR+1	;PLAYER'S HB Y
		;RESULT IS 0-16
		;MUST FIND IN ORDER OF DRAWN ORDER, THIS WILL MAKE IT EASIER TO CALCUATE THE BLOCK# IN CHUNK
	LDA LASTCURRENTBLOCK+1
	CMP #$FF	;BEYOND SCOPE, MUST BE SET FIST
	BNE :+
		JSR CALCULATECURRENTBLOCK
		LDA CURRENTBLOCK
		STA LASTCURRENTBLOCK
		LDA CURRENTBLOCK+1
		STA LASTCURRENTBLOCK+1
		;TRY AGAIN LATER
		RTS
	:	;NORMAL LOOP
	
	LDA CURRENTBLOCK
	CMP LASTCURRENTBLOCK
	BNE :+	;DIFFERENT BLOCK
		LDA CURRENTBLOCK+1
		CMP LASTCURRENTBLOCK+1
		BNE :+	;DIFFERENT BLOCK
		;ELSE THE CURRENT BLOCK IS THE SAME
		RTS
	:
	
		LDA LASTCURRENTBLOCK
		TAX
		LDA LASTCURRENTBLOCK+1
		JSR BLOCKNUMTOBITMAPCORD
		;FOR BLOCK #HLL
		;A = 0H, X = LL
		;RETURNS PROPER X[0-159] AND Y[0-120] IN STOREPOSITION
	
	;MULTIPLY STOREPOSITION+1 * 160 * 2
;[	;CLEAR SCREEN
	LDA STOREPOSITION+1
	STA FA
	LDA #$A0	;160
	STA FB
	JSR MULT
	LDA FA
	ASL
	STA FA
	LDA FB
	ROL
	STA FB
	;ADD IN TO LAYER 1 POSITION
	LDA FA
	CLC
	ADC STOREPOSITION
	STA ADDRL
	LDA FB
	ADC #$98
	STA ADDRM
	LDA #$10
	ADC #$00
	STA ADDRH
		;CLEAR LAST POSITION
		LDX #$00
		LDY #$00
		:
			LDA #$00
			STA DATA0
			INY
			CPY #$40	;64
			BEQ :+
			INX
			CPX #$08
			BNE :-
			LDX #$00
			LDA ADDRL
			CLC
			ADC #$38	;58
			STA ADDRL
			LDA ADDRM
			ADC #$01	;256 ;256+58=312
			STA ADDRM
			LDA ADDRH
			ADC #$00
			STA ADDRH
			JMP :-
		:
;]

		LDA CURRENTBLOCK
		TAX
		LDA CURRENTBLOCK+1
		JSR BLOCKNUMTOBITMAPCORD
		;FOR BLOCK #HLL
		;A = 0H, X = LL
		;RETURNS PROPER X[0-159] AND Y[0-120] IN STOREPOSITION
	
	;MULTIPLY STOREPOSITION+1 * 160 * 2
;[	;DRAW NEW BLOCK TO SCREEN SCREEN
	LDA STOREPOSITION+1
	STA FA
	LDA #$A0	;160
	STA FB
	JSR MULT
	LDA FA
	ASL
	STA FA
	LDA FB
	ROL
	STA FB
	;ADD IN TO LAYER 1 POSITION
	LDA FA
	CLC
	ADC STOREPOSITION
	STA ADDRL
	LDA FB
	ADC #$98
	STA ADDRM
	LDA #$10
	ADC #$00
	STA ADDRH
		;DRAW BLOCK 0 AT THIS POSITION ON LAYER 1
		LDX #$00
		LDY #$00
		LDA #$02
		STA RAMBANK	;SET TO 2ND BLOCK RAMBANK
		LDA #$00	;BLOCK #128, ONLY TOP
		STA POINTER
		LDA #$A0
		STA POINTER+1
		:
			LDA (POINTER), Y
			STA DATA0
			INY
			CPY #$40	;64
			BEQ :+
			INX
			CPX #$08
			BNE :-
			LDX #$00
			LDA ADDRL
			CLC
			ADC #$38	;58
			STA ADDRL
			LDA ADDRM
			ADC #$01	;256 ;256+58=312
			STA ADDRM
			LDA ADDRH
			ADC #$00
			STA ADDRH
			JMP :-
		:
;]
	
	;SET NEW LASTCURRENTBLOCK
		LDA CURRENTBLOCK
		STA LASTCURRENTBLOCK
		LDA CURRENTBLOCK+1
		STA LASTCURRENTBLOCK+1
	RTS
;]

BLOCKNUMTOBITMAPCORD:
;[
	;FOR BLOCK #HLL
	;A = 0H, X = LL
	;RETURNS PROPER X[0-159] AND Y[0-120] IN STOREPOSITION
	STA RENDERTMPA
	STX RENDERTMPX
	STX RENDERTMPY
	
	;STORE CURRENTLY USED RAMBANK
	LDA RAMBANK
	STA RAMBANKTMP
	
	;LAST 4 BITS OF X ACTUALLY NOT IMPORTANT, AND RELATE TO CURRENTZ
	LDX #$00
	:
		LSR RENDERTMPA
		ROR RENDERTMPX
		INX
		CPX #$03	;ONLY 2 TIMES, AS IT MUST ALSO BE MULTIPLIED BY 2
		BNE :-
	;THIS LEAVES THE HL [0-255] VALUE OF WHICH GRID SQUARE IT IS ON 
	;TO REACH ACCROSS TWO BYTES OF COORDINATE VALUE, WAS ALREADY MULTIPLIED BY 2 (ONLY DIVIDED BY 8, NOT 16)
	LDA RENDERTMPX
	AND #%11111110	;ZERO OUT LAST BIT
	STA POINTER
	LDA RENDERTMPA
	CLC
	ADC #$B8	;ADD $1800 TO $A0
	STA POINTER+1
	
	LDA QUICKTABLEBANK
	STA RAMBANK	;SET TO QUICKTABLE
	
	LDY #$00
	LDA (POINTER), Y
	CLC
		ADC #$10	;X-OFFSET
	STA STOREPOSITION
	INY
	LDA (POINTER), Y
	STA STOREPOSITION+1
	;ADJUST FOR Z LEVEL
		;+ ((16 - CURRENTZ) * 3)
		LDA RENDERTMPY	;OLD LL
		EOR #$FF	;FLIP BITS
		AND #$0F	;MASK OUT TOP BITS, LEFT ONLY WITH ZLEVEL
		CLC
		ADC #$01
	STA FA
	LDA #$03
	STA FB
	JSR MULT
	LDA FA
	CLC
	ADC STOREPOSITION+1
	;STA STOREPOSITION+1
		;ADD IN YOFFSET
		CLC
		ADC #$08
		STA STOREPOSITION+1
	
	
	ENDBLOCKNUMTOBITMAPCORD:
	;OLD LINE NUM: 3146
	;RESTORE RECENTLY USED RAMBANK
	LDA RAMBANKTMP
	STA RAMBANK
	RTS
;]

;]	


;MINING:
;[
DRAWCURSORBLOCK:
;[	DRAWS THE CURRENT CURSOR BLOCK ON LAYER 1
	;CURRENTBLOCK MAY NOT BE EXACTLY RIGHT, RERUN IT
		;CALLED WHEN MOVING OR CURSOR CHANGED
	JSR CALCULATECURRENTBLOCK
	LDA CURRENTBLOCK
	STA CURSORBLOCKNUM
	LDA CURRENTBLOCK+1
	STA CURSORBLOCKNUM+1
	;DIVIDE BY 16 TO GET LAYER VALUE IN CURSORBLOCKNUM
	LDX #$00
	:
		LSR CURSORBLOCKNUM+1
		ROR CURSORBLOCKNUM
		INX
		CPX #$04
		BNE :-
	LDA CURSORBLOCKNUM
	STA RENDERTMPA
	;SET PROPER RAMBANK
	LDA QUICKTABLEBANK
	STA RAMBANK
	
	CURRENTBLOCK_PLUS_CURSORBLOCK:
	;CURSORBLOCK: (XX_ZZ_BBBB)
	;  1		0 IS BLOCK PLAYER IS ON
	; 8 2
	;7 0 3
	; 6 4
	;  5 	
	;[
		LDA CURSORBLOCK
		AND #$0F	;MASK OUT TOP FOUR BITS
		CMP #$00
		BNE :+
			;CENTER
			JMP CONTINUEDRAWCURSORBLOCK
			JMP :+
			DEFCURSORSHORTCUT:
				JMP DEFCURSOR
		:
		CMP #$01
		BNE :+
			;TOP (ORTH -15)			
			LDA CURSORBLOCKNUM
			TAX
			LDA RENDERTABLE, X	;CONVERT FROM RENDER ORDER TO ORTH ORDER
			SEC
			SBC #$0F	;-15 ORTHGONALLY
				BCC DEFCURSORSHORTCUT	;IF WRAPS AROUND GOTO DEFAULT
				BEQ DEFCURSORSHORTCUT	;OR IF IS 0 (PLAYER ON SQUARE RENDERO$00)
			TAX
			LDA ORTHTABLE, X	;CONVERT FROM ORTH ORDER TO RENDER ORDER
			STA CURSORBLOCKNUM
			TAX
			LDA RENDERTABLE, X
			AND #$0F
			BEQ DEFCURSORSHORTCUT	;IF WRAPS FROM TOP RIGHT SIDE GOTO DEFAULT
			JMP CONTINUEDRAWCURSORBLOCK
		:
		CMP #$02
		BNE :+
			;TOP RIGHT (ORTH +1)
			LDA CURSORBLOCKNUM
			TAX
			LDA RENDERTABLE, X	;CONVERT FROM RENDER ORDER TO ORTH ORDER
			CLC
			ADC #$01	;-16 ORTHGONALLY
			TAX
			LDA ORTHTABLE, X	;CONVERT FROM ORTH ORDER TO RENDER ORDER
			STA CURSORBLOCKNUM
			TAX
			LDA RENDERTABLE, X
			AND #$0F
			BEQ DEFCURSORSHORTCUT	;IF WRAPS FROM TOP RIGHT SIDE GOTO DEFAULT
			JMP CONTINUEDRAWCURSORBLOCK
		:
		CMP #$03
		BNE :+
			;DIRECT RIGHT (ORTH +17)
			LDA CURSORBLOCKNUM
			TAX
			LDA RENDERTABLE, X	;CONVERT FROM RENDER ORDER TO ORTH ORDER
			CLC
			ADC #$11	;+17 ORTHOGONALLY
				BCS DEFCURSORSHORTCUT
			TAX
			LDA ORTHTABLE, X	;CONVERT FROM ORTH ORDER TO RENDER ORDER
			STA CURSORBLOCKNUM
			TAX
			LDA RENDERTABLE, X
			AND #$0F
			BEQ DEFCURSORSHORTCUT	;IF WRAPS FROM TOP RIGHT SIDE GOTO DEFAULT
			JMP CONTINUEDRAWCURSORBLOCK
		:
		CMP #$04
		BNE :+
			;BOTTOM RIGHT (ORTH +16)
			LDA CURSORBLOCKNUM
			TAX
			LDA RENDERTABLE, X	;CONVERT FROM RENDER ORDER TO ORTH ORDER
			CLC
			ADC #$10	;+17 ORTHOGONALLY
				BCS DEFCURSORSHORTCUT
			TAX
			LDA ORTHTABLE, X	;CONVERT FROM ORTH ORDER TO RENDER ORDER
			STA CURSORBLOCKNUM
			JMP CONTINUEDRAWCURSORBLOCK
		:
		CMP #$05
		BNE :+
			;DIRECT DOWN (ORTH +15)			
			LDA CURSORBLOCKNUM
			TAX
			LDA RENDERTABLE, X	;CONVERT FROM RENDER ORDER TO ORTH ORDER
			CLC
			ADC #$0F	;+15 ORTHGONALLY
				BCS DEFCURSOR	;IF WRAPS AROUND GOTO DEFAULT
				CMP #$F0
				BEQ DEFCURSOR	;OR IF IS $F0 (PLAYER ON SQUARE RENDERO$FF)
			TAX
			LDA ORTHTABLE, X	;CONVERT FROM ORTH ORDER TO RENDER ORDER
			STA CURSORBLOCKNUM
			TAX
			LDA RENDERTABLE, X
			AND #$0F
			CMP #$0F
			BEQ DEFCURSOR	;IF WRAPS FROM BOTTOM LEFT SIDE GOTO DEFAULT
			JMP CONTINUEDRAWCURSORBLOCK
		:
		CMP #$06
		BNE :+
			;BOTTOM LEFT (ORTH -1)			
			LDA CURSORBLOCKNUM
			TAX
			LDA RENDERTABLE, X	;CONVERT FROM RENDER ORDER TO ORTH ORDER
			SEC
			SBC #$01	;-1 ORTHGONALLY
			TAX
			LDA ORTHTABLE, X	;CONVERT FROM ORTH ORDER TO RENDER ORDER
			STA CURSORBLOCKNUM
			TAX
			LDA RENDERTABLE, X
			AND #$0F
			CMP #$0F
			BEQ DEFCURSOR	;IF WRAPS FROM BOTTOM LEFT SIDE GOTO DEFAULT
			JMP CONTINUEDRAWCURSORBLOCK
		:
		CMP #$07
		BNE :+
			;DIRECT LEFT (ORTH -17)			
			LDA CURSORBLOCKNUM
			TAX
			LDA RENDERTABLE, X	;CONVERT FROM RENDER ORDER TO ORTH ORDER
			SEC
			SBC #$11	;-17 ORTHGONALLY
				BCC DEFCURSOR	;IF WRAPS AROUND GOTO DEFAULT
			TAX
			LDA ORTHTABLE, X	;CONVERT FROM ORTH ORDER TO RENDER ORDER
			STA CURSORBLOCKNUM
			TAX
			LDA RENDERTABLE, X
			AND #$0F
			CMP #$0F
			BEQ DEFCURSOR	;IF WRAPS FROM BOTTOM LEFT SIDE GOTO DEFAULT
			JMP CONTINUEDRAWCURSORBLOCK
			JMP CONTINUEDRAWCURSORBLOCK
		:
		CMP #$08
		BNE :+
			;TOP LEFT (ORTH -16)			
			LDA CURSORBLOCKNUM
			TAX
			LDA RENDERTABLE, X	;CONVERT FROM RENDER ORDER TO ORTH ORDER
			SEC
			SBC #$10	;-16 ORTHGONALLY
				BCC DEFCURSOR	;IF WRAPS AROUND GOTO DEFAULT
			TAX
			LDA ORTHTABLE, X	;CONVERT FROM ORTH ORDER TO RENDER ORDER
			STA CURSORBLOCKNUM
			JMP CONTINUEDRAWCURSORBLOCK
		:
	;]
	DEFCURSOR:
		LDA RENDERTMPA
		STA CURSORBLOCKNUM
		
	CONTINUEDRAWCURSORBLOCK:
	;MULTIPLY BY 16
	LDX #$00
	:
		ASL CURSORBLOCKNUM
		ROL CURSORBLOCKNUM+1
		INX
		CPX #$04
		BNE :-

	;CALCULATE FURTHER Z LEVELS: (XX_ZZ_BBBB)
	LDA CURSORBLOCK
	AND #%00110000
	LDX #$00
	:
		LSR
		INX
		CPX #$04
		BNE :-	;NOW MOVED ZHEIGHT TO BOTTOM TWO BITS
		STA RENDERTMPX	;FOR TEMPORARY STORAGE AND USE LATER
		STA RENDERTMPX+1
	LDA CURRENTZ
	STA RENDERTMPY	;THIS USES THE FACT THAT THE LAST FOUR BITS OF THE CURRENTBLOCK ARE THE SAME AS THE CURRENTZ
	LDX #$00
	:
		LDA RENDERTMPX
		BEQ :+	;COMPARE TO 0
			;ELSE INCREASE Z IF POSSIBLE
			;IF SECOND HALF OF CURSORBLOCK IS LESS THAN F, INCREASE THE VALUE
			LDA RENDERTMPY
			CMP #$0F
			BCS :+	;NO MORE
			;ELSE INCREASE IT:
			INC RENDERTMPY
			DEC RENDERTMPX
			JMP :-
	:
		;STORE NEW Z IN CURSORBLOCKNUM
		LDA CURSORBLOCKNUM
		AND #$F0	;MASK FOUR LOWER BITS
		CLC
		ADC RENDERTMPY	;ADD IN NEW Z
		STA CURSORBLOCKNUM
	;CALCULATE NEW CURSORBUFFERPOS
	LDA CURSORBLOCKNUM
	TAX
	LDA CURSORBLOCKNUM+1
	JSR BLOCKNUMTOBITMAPCORD	;RESULTS IN STOREPOSITION
	LDA STOREPOSITION
	STA CURSORBUFFERPOS
	LDA STOREPOSITION+1
	STA CURSORBUFFERPOS+1

	;STORE IN CURSOR SPRITE POSITION
	LDA CURSORSPRITEPOINTER
	CLC
	ADC #$02	;POINTING TO X
	STA ADDRL
	LDA CURSORSPRITEPOINTER+1
	STA ADDRM
	LDA #$21	;STEP = 2
	STA ADDRH
	
	;CALCULATE NEW CURSOR POSITION:
	LDA CURSORBUFFERPOS
	STA DATA0
	LDA CURSORBUFFERPOS+1
	STA DATA0
	
	;SET THE Z SPRITE:
	LDA CURSORSPRITEPOINTER
	STA ADDRL
	LDA CURSORSPRITEPOINTER+1
	STA ADDRM
	LDA #$01
	STA ADDRH
	
	LDA RENDERTMPX+1
	ASL
	CLC
	ADC #$80	;BASE SPRITE
	STA DATA0
	
	;CHECK FOR SPRITE ORDER:
	;IF CURSORBLOCK'S Z IS 0 (STORED IN RENDERTMPX+1), BEHIND THE PLAYER, IF 3 IS ABOVE THE PLAYER
	;IF Z IS 1 OR 2 THEN IF CURSORBLOCK >=4 & !8 THEN IS IN FRONT OF PLAYER, ELSE IS BEHIND 
	;CURSORBLOCKPRIORITY	;0 IF BELOW PLAYER, 1 IF ABOVE PLAYER
	LDA RENDERTMPX+1
	CMP #$00	;BOTTOM
	BNE CHECKLEVEL3
		JMP CHECKCURSORBEHIND
	CHECKLEVEL3:
		CMP #$03
		BNE MIDDLELEVELCURSOR
		JMP CHECKCURSORINFRONT
	
	MIDDLELEVELCURSOR:
		LDA CURSORBLOCK
		AND #$0F	;ONLY 0-8
		CMP #$00
		BEQ SETBLANKCURSOR
		CMP #$04
		BCC CHECKCURSORBEHIND
		CMP #$08
		BEQ CHECKCURSORBEHIND
	CHECKCURSORINFRONT:
		LDA CURSORBLOCKPRIORITY
		CMP #$01
		BEQ :+
			JSR SWITCHCURSORSPRITETOTOPOFPLAYER
		:		
		JMP ENDDRAWCURSORBLOCK
	CHECKCURSORBEHIND:
		LDA CURSORBLOCKPRIORITY
		CMP #$00
		BEQ :+
			JSR SWITCHPLAYERSPRITETOTOPOFCURSOR
		:
		JMP ENDDRAWCURSORBLOCK
	SETBLANKCURSOR:
		LDA CURSORSPRITEPOINTER
		STA ADDRL
		LDA CURSORSPRITEPOINTER+1
		STA ADDRM
		LDA #$01
		STA ADDRH
		LDA BLANKSPRITELOCATION
		STA DATA0

	ENDDRAWCURSORBLOCK:
	RTS
;]

SWITCHPLAYERSPRITETOTOPOFCURSOR:
;[	;CURSOR IS THE ONE ON TOP (FIRST IN SPRITE QUEUE)
	LDA CURSORSPRITEPOINTER
	STA RENDERTMPA
	STA ADDRL
	LDA CURSORSPRITEPOINTER+1
	STA RENDERTMPA+1
	STA ADDRM
	LDA #$11
	STA ADDRH
		LDA #$00
		STA CURSORBLOCKPRIORITY
	JMP SWAPCURSORANDPLAYERSPRITE
;]

SWITCHCURSORSPRITETOTOPOFPLAYER:
;[	;PLAYERSPRITE IS THE ONE ON TOP (FIRST IN SPRITE QUEUE)
	LDA PLAYERSPRITE
	STA RENDERTMPA
	STA ADDRL
	LDA PLAYERSPRITE+1
	STA RENDERTMPA+1
	STA ADDRM
	LDA #$11
	STA ADDRH
		LDA #$01
		STA CURSORBLOCKPRIORITY
	JMP SWAPCURSORANDPLAYERSPRITE
;]

SWAPCURSORANDPLAYERSPRITE:
;[
	;MOVE ALL 16B TO A BUFFER THEN LOAD IN BOTTOM 8, THEN TOP 8
	LDX #$00
	:
		LDA DATA0
		STA SPRITESWAPBUFFERHIGH, X
		INX
		CPX #$10
		BNE :-
	;RESET LOCATION
	LDA RENDERTMPA
	STA ADDRL
	LDA RENDERTMPA+1
	STA ADDRM
	LDA #$11
	STA ADDRH
	
	LDX #$00
	:
		LDA SPRITESWAPBUFFERLOW, X
		STA DATA0
		INX
		CPX #$08
		BNE :-
	LDX #$00
	:
		LDA SPRITESWAPBUFFERHIGH, X
		STA DATA0
		INX
		CPX #$08
		BNE :-
		
	;SWAP CURSORSPRITEPOINTER AND PLAYERSPRITE
	LDA PLAYERSPRITE
	TAX
	LDA PLAYERSPRITE+1
	TAY
	LDA CURSORSPRITEPOINTER
	STA PLAYERSPRITE
	LDA CURSORSPRITEPOINTER+1
	STA PLAYERSPRITE+1
	TXA 
	STA CURSORSPRITEPOINTER
	TYA 
	STA CURSORSPRITEPOINTER+1
	RTS
;]

PLACEBLOCK:	;USES POINTER
;[ PLACEBLOCK @CURSORBLOCKNUM IF EMPTY		
	
	;CHECK IF IN PLAYER'S TWO POSITIONS:
		LDA CURSORBLOCK
		CMP #$10
		BEQ ENDPLACEBLOCK
		CMP #$20
		BEQ ENDPLACEBLOCK
	;LOAD CENTERCHUNK
		LDA COMPASSPOINTER+4	;CENTER CHUNK
		STA RAMBANK	;SET TO CENTRAL CHUNK
	;CHECK IF SOLID BLOCK
		LDA CURSORBLOCKNUM
		STA POINTER
		LDA CURSORBLOCKNUM+1
		CLC
		ADC #$A0	;POINT TO RAMBANK + CURSORBLOCKNUM
		STA POINTER+1
		LDY #$00
		LDA (POINTER), Y
		CMP #$00	;AIR
		BNE SETMINING		
	;CHECK IF IS BLOCK (NOT ITEM)
		LDA CURRENTINV	;ALREADY SET TO 0-7
		ASL
		TAX
		LDA INVENTORY, X
		CMP #$80
		BCS ENDPLACEBLOCK	;IS ITEM NOT BLOCK
		STA TMPA

	;PLACE BLOCK
		LDA TMPA	;BLOCK TYPE
		STA (POINTER), Y
		JSR QUICKPATCH
		JMP ENDPLACEBLOCK
	
	SETMINING:
			LDA CURSORBLOCKNUM
			STA MININGTARGET
			LDA CURSORBLOCKNUM+1
			STA MININGTARGET+1
			LDA MINEFLAGS
				ORA #$C0
				AND #$F0	;TURN ON MINING BIT, A HELD BIT, AND 0 OUT TIMER 
			STA MINEFLAGS
			LDA #$10
			STA MICROTIMER
		JMP ENDPLACEBLOCK
	
	
	ENDPLACEBLOCK:
	RTS
;]

KEEPMINING:
;[	WILL CONTINUE INCREASING THE MINING TIME UNTIL THE TARGETED BLOCK IS BROKEN
	;CHECK IF CURSOR HAS MOVED
	LDA CURSORBLOCKNUM
	CMP MININGTARGET
		BNE TURNOFFMINING
	LDA CURSORBLOCKNUM+1
	CMP MININGTARGET+1
		BNE TURNOFFMINING
	
	;INCREASE MINING TIMER
	LDA MICROTIMER
		INC
		CMP MTIMESLICE
		BCC :+
			INC MINEFLAGS
			LDA #$00
	:
	STA MICROTIMER
	
	;COMPARE WITH BLOCK TIMER
		LDA MINEFLAGS
		AND #$0F
		CMP #$02
		BCC ENDKEEPMINING
		;BREAK BLOCK
			;LOAD CENTERCHUNK
			LDA COMPASSPOINTER+4	;CENTER CHUNK
			STA RAMBANK	;SET TO CENTRAL CHUNK
		;CHECK IF SOLID BLOCK
			LDA CURSORBLOCKNUM
			STA POINTER
			LDA CURSORBLOCKNUM+1
			CLC
			ADC #$A0	;POINT TO RAMBANK + CURSORBLOCKNUM
			STA POINTER+1
			LDY #$00
				;MOVE TO INVENTORY
				LDA CURRENTINV
				ASL
				TAX
				LDA (POINTER), Y	;LOAD BLOCK TYPE
				STA INVENTORY, X
			;CLEAR BLOCK
			LDA #$00	;AIR
			STA (POINTER), Y
			JSR QUICKPATCH
			JSR DRAWITEMSONBAR
	
	TURNOFFMINING:
		LDA MINEFLAGS
		AND #%01110000
		STA MINEFLAGS	;TUNING OFF TIMER AND MINING FLAG
	
	ENDKEEPMINING:
	RTS
;]


QUICKPATCH:	;FROM CURSORBLOCKNUM LOCATION
;[
	;GET BLOCK LOCATION:
	LDA CURSORBLOCKNUM
	AND #$0F
	SEC
	SBC #$01
	CMP #$FF
	BNE :+
		LDA #$00
	:
	LDA #$00	;MUST ALWAYS GO FROM LOWEST FOR MINING AWAY
	STA PATCHTMPZ
	;USE A LITTLE TRICK, I JUST USE THE CURRENT SPRITE LOCATION (SHOULD BE IN CURSORBUFFERPOS)
	LDA CURSORBUFFERPOS
		CLC
		ADC #$04
	STA PATCHTMPX
	STA CHECKPLAYERBOUND
	LDA CURSORBUFFERPOS+1
		CLC
		ADC #$08
	STA PATCHTMPY
	CLC
	ADC #$1C
	STA CHECKPLAYERBOUND+1
	
	;THE REST OF IT
	LDA COMPASSPOINTER+4	;CENTER CHUNK
	STA RAMBANK	;SET TO CENTRAL CHUNK
	
	LDA CHUNKOFFSETX+4	;CENTRAL CHUNK
	CLC
	ADC #$3C	;DON'T KNOW WHAT THESE VALUES MEAN BUT THEY WORK
	STA STOREPOSITION
	STA LOADPOSITION
	LDA CHUNKOFFSETY+4
	CLC
	ADC #$1C	;DON'T KNOW WHAT THESE VALUES MEAN BUT THEY WORK
	STA STOREPOSITION+1
	STA LOADPOSITION+1
	
	LDA #$00
	STA CURRENTLINE
	STA BITTMPA		;COUNTS BLOCK NUMBER
	

	
	LDA #$00
	STA POINTER2
	LDA #$A0
	STA POINTER2+1	;POINTING TO CHUNKDATA IN RAMBANK
	

	
	;CLEAR PATCH
	LDX #$00
	LDA #$00
	:
		STA PATCH, X
		INX
		CPX #$00
		BNE :-
	
	LDA #$00
	STA OVERFLOWHEIGHTPERLAYER
	
	LDX #$00
	STX BITTMPX
	LDY #$00
	STY BITTMPY
	PATCH_OVERLAYCALCLOOP:
		;SET  TO ONLY Y ABOVE PATCHTMPZ
		LDA LOADPOSITION+1	;COLUMN BASE Y
		LDX #$00
		INC PATCHTMPZ
		:
			SEC
			SBC #$03	;UP BY 3 EACH TIME
			INC BITTMPY
			INX
			CPX PATCHTMPZ
			BEQ :+
			JMP :-
		:
		DEC PATCHTMPZ
		STA STOREPOSITION+1
		
	PATCH_CHECKOVERLAY:
			;COMPARE IF 8X8 RECT AROUND STOREPOSITION HOLDS CHECKPLAYERBOUND:	
		LDY BITTMPY
		LDA (POINTER2), Y
		CMP #$00	;AIR
		BNE :+
			JMP PATCH_NEXTINOVERLAY
		:
		STA BITTMPA
			LDA CHECKPLAYERBOUND
			CMP STOREPOSITION
			BCC :+
				LDA STOREPOSITION
				CLC
				ADC #$08	;9 BECAUSE CAN ONLY MEASURE >=
				CMP CHECKPLAYERBOUND
				BCC :+
			;TEST Y
				;CHECK HERE FOR PLAYER COLLISION HEIGHT ON THIS LEVEL
				LDA BITTMPY
				AND #$0F	;MASK HIGH 4 BITS
				SEC
				SBC PATCHTMPZ	;RESULT IS ALWAYS GREATER THAN 0
				STA BITTMPA+1	;YES, IT HAS RESERVE 2
				LDX #$00
				LDA #$00
				
				;EACH ROW IS FULL
				LDA #$10
				STA OVERFLOWHEIGHTPERLAYER	;WILL ONLY EVER BE 3, 6, 9, 12, 15, 18 DEPENDING ON PATCHTMPZ
					
			LDA CHECKPLAYERBOUND+1
			CMP STOREPOSITION+1
			BCC :+
				LDA STOREPOSITION+1
				CLC
				ADC OVERFLOWHEIGHTPERLAYER
				CMP CHECKPLAYERBOUND+1
				BCC :+
				;YES IT IS WITHIN THIS BOX, COPY TO OVERFLOW BUFFER
				JMP :++
			:
				JMP PATCH_NEXTINOVERLAY
			:
			LDA BITTMPA
			CMP #$80
			BCC :+	
					LDA BITTMPA
					SEC
					SBC #$80
					STA BITTMPA
				LDA #$02	;2ND HALF OF BLOCKS
				JMP :++
			:
				LDA #$01	;FIRST HALF OF BLOCKS
			:
			STA RAMBANK	;SET TO PROPER BANK
			LDA BITTMPA
			STA FA
			LDA #$40
			STA FB
			JSR MULT
			LDA FA
			STA POINTER
			LDA FB
			CLC
			ADC #$A0
			STA POINTER+1	;POINT TO PROPER BLOCK DATA
			;SET TO RIGHT BUFFER COORDINATES
			LDA STOREPOSITION+1
			LDA PATCHTMPY	;Y
			SEC
			SBC STOREPOSITION+1
			ASL
			ASL
			ASL
			ASL	;*16	;# OF PIXELS OVER TOP
			SEC
			SBC #$30
			STA BITTMPA
			LDA #$00
			SEC
			SBC BITTMPA
			STA BITTMPA
			
			LDA PATCHTMPX	;X
			SEC
			SBC STOREPOSITION	;#OF PIXELS OVER IN BUFFER ON RIGHT SIDE
			EOR #$FF	;BITWISE NOT
			AND #$0F	;MASK OUT TOP BITS
			SEC
			SBC #$07
			CLC
			ADC BITTMPA
			TAX
			
			LDY #$00
			LDA #$00
			STA BITTMPA
				:
				LDA (POINTER), Y
				CMP #$00
				BEQ PATCH_AFTEROVERPLACE
					STA PATCH, X
					PATCH_AFTEROVERPLACE:
				INX
				INY
				CPY #$40
				BEQ :+
				INC BITTMPA
				LDA BITTMPA
				CMP #$08
				BNE :-
				LDA #$00
				STA BITTMPA
				TXA
				CLC
				ADC #$08
				TAX
				CPX #$10
				BCC :+	;END IT ALL AFTER LOOPED OVER TOP
				JMP :-
			:
				
			LDA COMPASSPOINTER+4	;CENTER CHUNK
			STA RAMBANK	;SET TO CENTRAL CHUNK

		PATCH_NEXTINOVERLAY:
		INC BITTMPY
			;SUBTRACT 3 FROM THE STORE POSITION
			LDA STOREPOSITION+1
			SEC
			SBC #$03
			STA STOREPOSITION+1
		;CHECK IF Y OVERFLOW
		LDA BITTMPY
		CMP #$00
		BNE :+
			INC POINTER2+1
		:
		LDA BITTMPY
		AND #$0F	;CHECK IF HIT 16 BLOCKS YET
		BEQ :+	
			JMP PATCH_CHECKOVERLAY
		:
		INC BITTMPX
		LDX CURRENTLINE
		LDA LINELENGTH, X	;GIVES LENGTH OF CURRENT LINE
		CMP BITTMPX
		BEQ PATCH_NECTOVERLAYLINE
			;ELSE INCREASE STOREPOSITION BY +8
			LDA STOREPOSITION
			CLC
			ADC #$08
			STA STOREPOSITION
			;AND RESET STOREPOSITION+1
			LDA LOADPOSITION+1
			STA STOREPOSITION+1
			JMP PATCH_OVERLAYCALCLOOP
		PATCH_NECTOVERLAYLINE:
			LDA CURRENTLINE
			CMP #$1E	;31 LINES IN A BLOCK
			BEQ PATCH_ENDOVERLAYCALC
			;IF CURRENTLINE IS < 16, DECREASE LOADPOSITION BY 4
			;ELSE INCREASE BY 4
			CMP #$0F
			BCS :+ 
				LDA LOADPOSITION
				SEC
				SBC #$04
				STA LOADPOSITION
				STA STOREPOSITION
				JMP :++
			:
				LDA LOADPOSITION
				CLC
				ADC #$04
				STA LOADPOSITION
				STA STOREPOSITION
			:
			;INCREASE LOADPOSITION+1 BY 3
			LDA LOADPOSITION+1
			CLC
			ADC #$03
			STA LOADPOSITION+1
			STA STOREPOSITION+1
			;INCREASE CURRENTLINE AND RESET OTHER VARS
			INC CURRENTLINE
			LDA #$00
			STA BITTMPX
			JMP PATCH_OVERLAYCALCLOOP
			
		PATCH_ENDOVERLAYCALC:
		;GET VRAM LOCATION:
		LDA CURSORBUFFERPOS+1
		STA FA
		LDA #$A0
		STA FB
		JSR MULT
		LDA FA
		ASL
			STA ADDRL
		LDA FB
		ROL
			STA ADDRM
		LDA ADDRL
		CLC
		ADC CURSORBUFFERPOS
		STA ADDRL
		LDA ADDRM
		ADC #$00
		STA ADDRM
		LDA #$10
		STA ADDRH
		
		;DRAW TO LAYER 0
		LDA #$00
		STA PATCHTMPZ
		LDY #$00
		LDX #$74	;60
		:
			LDA PATCH, X
				BNE FILLNEWBLOCK
					LDA DATA0
					JMP AFTERNEWBLOCK
				FILLNEWBLOCK:
				STA DATA0
			AFTERNEWBLOCK:	
			INX
			INY
			CPY #$08
			BNE :-
				LDY #$00
				LDA PATCHTMPZ
				INC
				CMP #$08
				BEQ :+
			STA PATCHTMPZ
				TXA
				CLC
				ADC #$08
				TAX
				;ADD 320-8 TO DATA0
				LDA ADDRL
				CLC
				ADC #$38
				STA ADDRL
				LDA ADDRM
				ADC #$01
				STA ADDRM
			JMP :-
		:
	RTS
;]


;]	END MINING





;LAYER 1 FUNCTIONS
;[
DRAWCOORDINATESONLAYER1:
;[	;CLEARS AND THEN DRAWS THE COORDINATES ON  LAYER1 (USES TMPX, POINTER)
	;JSR CLEARCOORDINATESONLAYER1
	LDA #$58
	STA ADDRL
	LDA #$99	
	STA ADDRM
	LDA #$10
	STA ADDRH	;SET ADDRESS TO $09940, SKIP FIRST LINE
	
	;CALCULATE STRING 
	;[
	;CORSTRING "X:00 Y:00 Z:00"
	LDA #$18	;"X"
	STA CORSTRING
	LDA #$19	;"Y"
	STA CORSTRING+5
	LDA #$1A	;"Z"
	STA CORSTRING+10
	
	;COORDINATE TO ORTHCOORDINATE
	LDA CURRENTBLOCK+1
		STA TMPX
	LDA CURRENTBLOCK
		STA TMPY
	LDX #$04
	:
		LSR TMPX
		ROR TMPY
		DEX
		BNE :-
	LDY TMPY
	LDA QUICKTABLEBANK
	STA RAMBANK
	LDA #$00
	STA POINTER
	LDA #$BB
	STA POINTER+1
	LDA (POINTER), Y	;GET ORTH NUMBER
	AND #$0F
	STA TMPX
	LDA (POINTER), Y	;GET ORTH NUMBER
	AND #$F0
	LDX #$04
	:
		LSR
		DEX
		BNE :-
	STA TMPY
	
	;XCOORDINATE:
	LDA TMPX
	CMP #$0A
	BCC :+
		LDA #$31	;"1"
		STA CORSTRING+2
		LDA TMPX
		SEC
		SBC #$0A
		JMP :++
	:
		LDA #$30	;"0"
		STA CORSTRING+2
		LDA TMPX
	:
		CLC
		ADC #$30
		STA CORSTRING+3
	
	;YCOORDINATE:
	LDA TMPY
	CMP #$0A
	BCC :+
		LDA #$31	;"1"
		STA CORSTRING+7
		LDA TMPY
		SEC
		SBC #$0A
		JMP :++
	:
		LDA #$30	;"0"
		STA CORSTRING+7
		LDA TMPY
	:
		CLC
		ADC #$30
		STA CORSTRING+8
	
	;ZLEVEL
	LDA CURRENTZ
	CMP #$0A
	BCC :+
		LDA #$31	;"1"
		STA CORSTRING+12
		LDA CURRENTZ
		SEC
		SBC #$0A
		JMP :++
	:
		LDA #$30	;"0"
		STA CORSTRING+12
		LDA CURRENTZ
	:
		CLC
		ADC #$30
		STA CORSTRING+13
	;]
	
	;SET TO CRAFTSCIIBANK
	LDA CRAFTSCIIBANK
	STA RAMBANK	
	
	LDX #$00
	DRAWCORCHARLOOPINNERCHUNK:
		STX TMPX
			LDA CORSTRING, X	;CHARACTER#
			STA FA
			LDA #$40
			STA FB
			JSR MULT
			
		LDA FA
		STA POINTER
		LDA FB
		CLC
		ADC #$A0
		STA POINTER+1
		
		LDX #$00
		LDY #$00
		:
			LDA (POINTER), Y
				CMP #$00
				BEQ DRAWCHARLOCAL
					;ELSE COLORIZE
					CLC
					ADC #$0E
			DRAWCHARLOCAL:
			STA DATA0
			INY
				CPY #$40	;64
				BEQ :+
			INX
			CPX #$08
			BNE :-
			;ADD 312 TO DATA0
			LDX #$00
			LDA ADDRL
			CLC
			ADC #$38
			STA ADDRL
			LDA ADDRM
			ADC #$01
			STA ADDRM
			JMP :-
		:	
		LDX TMPX
		INX
		CPX #$0E	;14
		BEQ ENDDRAWCORCHARLOCAL
			;SUBTRACT (320*7) ($0A00) THEN WRITE THE NEXT CHARACTER
			LDA ADDRL
			SEC
			SBC #$C0
			STA ADDRL
			LDA ADDRM
			SBC #$08
			STA ADDRM
		JMP DRAWCORCHARLOOPINNERCHUNK
	
	ENDDRAWCORCHARLOCAL:
	RTS
;]

DRAWGLOBALCOORDINATESONLAYER1:
;[	;CLEARS AND THEN DRAWS THE COORDINATES ON  LAYER1 (USES TMPX, POINTER)
	JSR CLEARCOORDINATESONLAYER1
	LDA #$40
	STA ADDRL
	LDA #$99	
	STA ADDRM
	LDA #$10
	STA ADDRH	;SET ADDRESS TO $09940, SKIP FIRST LINE
	
	;CALCULATE STRING 
	;[
	;CORSTRING "X:00 Y:00 Z:00"
	LDA #$18	;"X"
	STA CORSTRING
	LDA #$19	;"Y"
	STA CORSTRING+7
	LDA #$1A	;"Z"
	STA CORSTRING+14
	;GLOBALCOMPASS * 16
		;THE MIDDLE CHUNK SHOULD NOW BE FAAA, FAAA FOR REFERENCE (5000, 5000)
	;THERE IS NO PROPER BLOCK X/Y, SO JUST KEEP TRACK OF THE CHUNKS, THAT'S EASIER ANYWAYS
	;X
	LDA GLOBALCOMPASS
	AND #$F0
	LSR
	LSR
	LSR
	LSR
	JSR HEXDIGITTOCHAR
	STA CORSTRING+2
	LDA GLOBALCOMPASS
	AND #$0F
	JSR HEXDIGITTOCHAR
	STA CORSTRING+3
	LDA GLOBALCOMPASS+1
	AND #$F0
	LSR
	LSR
	LSR
	LSR
	JSR HEXDIGITTOCHAR
	STA CORSTRING+4
	LDA GLOBALCOMPASS+1
	AND #$0F
	JSR HEXDIGITTOCHAR
	STA CORSTRING+5
	;Y
	LDA GLOBALCOMPASS+2
	AND #$F0
	LSR
	LSR
	LSR
	LSR
	JSR HEXDIGITTOCHAR
	STA CORSTRING+9
	LDA GLOBALCOMPASS+2
	AND #$0F
	JSR HEXDIGITTOCHAR
	STA CORSTRING+10
	LDA GLOBALCOMPASS+3
	AND #$F0
	LSR
	LSR
	LSR
	LSR
	JSR HEXDIGITTOCHAR
	STA CORSTRING+11
	LDA GLOBALCOMPASS+3
	AND #$0F
	JSR HEXDIGITTOCHAR
	STA CORSTRING+12
	
	;ZLEVEL
	LDA CURRENTZ
	CMP #$0A
	BCC :+
		LDA #$31	;"1"
		STA CORSTRING+16
		LDA CURRENTZ
		SEC
		SBC #$0A
		JMP :++
	:
		LDA #$30	;"0"
		STA CORSTRING+16
		LDA CURRENTZ
	:
		CLC
		ADC #$30
		STA CORSTRING+17
	;]
	
	;SET TO CRAFTSCIIBANK
	LDA CRAFTSCIIBANK
	STA RAMBANK	
	
	LDX #$00
	DRAWCORCHARLOOP:
		STX TMPX
			LDA CORSTRING, X	;CHARACTER#
			STA FA
			LDA #$40
			STA FB
			JSR MULT
			
		LDA FA
		STA POINTER
		LDA FB
		CLC
		ADC #$A0
		STA POINTER+1
		
		LDX #$00
		LDY #$00
		:
			LDA (POINTER), Y
				CMP #$00
				BEQ DRAWCHAR
					;ELSE COLORIZE
					CLC
					ADC #$0E
			DRAWCHAR:
			STA DATA0
			INY
				CPY #$40	;64
				BEQ :+
			INX
			CPX #$08
			BNE :-
			;ADD 312 TO DATA0
			LDX #$00
			LDA ADDRL
			CLC
			ADC #$38
			STA ADDRL
			LDA ADDRM
			ADC #$01
			STA ADDRM
			JMP :-
		:	
		LDX TMPX
		INX
		CPX #$12	;18
		BEQ ENDDRAWCORCHAR
			;SUBTRACT (320*7) ($0A00) THEN WRITE THE NEXT CHARACTER
			LDA ADDRL
			SEC
			SBC #$C0
			STA ADDRL
			LDA ADDRM
			SBC #$08
			STA ADDRM
		JMP DRAWCORCHARLOOP
	
	ENDDRAWCORCHAR:
	RTS
;]


CLEARCOORDINATESONLAYER1:
;[	;CLEARS THE FIRST 8 LINES OF LAYER 1 IN VRAM
	LDA #$40
	STA ADDRL
	LDA #$99	
	STA ADDRM
	LDA #$10
	STA ADDRH	;SET ADDRESS TO $09800
	
	LDX #$00
	LDY #$00
	:
		LDA #$00
		STA DATA0
		INX
		CPX #$A0	;160
		BNE :-
		LDX #$00
		INY
		CPY #$08
		BEQ :+
			;ADD 160 TO DATA0
			LDA ADDRL
			CLC
			ADC #$A0
			STA ADDRL
			LDA ADDRM
			ADC #$00
			STA ADDRM
			;WILL NEVER REACH BEYOND $0B100 SO NO NEED TO CARRY HIGH CARRY
		JMP :-
	:	
	RTS
;]

DRAWPLAYEROVERLAYONLAYER1:
;[	CALCULATES, CLEARS, THEN DRAWS PLAYER OVERLAY ON LAYER1 BASED ON CURRENTZ
	;NEVER ARRIVES HERE WHEN CURRENTZ == #$0F
	;THE OVERLAYBUFFER IS A 16X16 ARRANGEMENT OF PIXELS
	;LOAD CENTRAL CHUNK (PROBABLY REDUNDANT, BUT YOU NEVER KNOW)
	LDA COMPASSPOINTER+4	;CENTER CHUNK
	STA RAMBANK	;SET TO CENTRAL CHUNK
	
	LDA CHUNKOFFSETX+4	;CENTRAL CHUNK
	CLC
	ADC #$3C	;DON'T KNOW WHAT THESE VALUES MEAN BUT THEY WORK
	STA STOREPOSITION
	STA LOADPOSITION
	LDA CHUNKOFFSETY+4
	CLC
	ADC #$1C	;DON'T KNOW WHAT THESE VALUES MEAN BUT THEY WORK
	STA STOREPOSITION+1
	STA LOADPOSITION+1
	
	LDA #$00
	STA CURRENTLINE
	STA BITTMPA		;COUNTS BLOCK NUMBER
	
	LDA PLAYERCOR
	STA CHECKPLAYERBOUND
	LDA PLAYERCOR+1
	CLC
	ADC #$1C
	STA CHECKPLAYERBOUND+1
	
	LDA #$00
	STA POINTER2
	LDA #$A0
	STA POINTER2+1	;POINTING TO CHUNKDATA IN RAMBANK
	

	
	;CLEAR OVERLAYBUFFER
	LDX #$00
	LDA #$00
	:
		STA OVERLAYBUFFER, X
		INX
		CPX #$00
		BNE :-
	
	LDA #$00
	STA OVERFLOWHEIGHTPERLAYER
	
	LDX #$00
	STX BITTMPX
	LDY #$00
	STY BITTMPY
	OVERLAYCALCLOOP:
		;SET  TO ONLY Y ABOVE CURRENTZ
		LDA LOADPOSITION+1	;COLUMN BASE Y
		LDX #$00
		INC CURRENTZ
		:
			SEC
			SBC #$03	;UP BY 3 EACH TIME
			INC BITTMPY
			INX
			CPX CURRENTZ
			BEQ :+
			JMP :-
		:
		DEC CURRENTZ
		STA STOREPOSITION+1
		
	CHECKOVERLAY:
			;COMPARE IF 8X8 RECT AROUND STOREPOSITION HOLDS CHECKPLAYERBOUND:	
		LDY BITTMPY
		LDA (POINTER2), Y
		CMP #$00	;AIR
		BNE :+
			JMP NEXTINOVERLAY
		:
		STA BITTMPA
			LDA CHECKPLAYERBOUND
			CMP STOREPOSITION
			BCC :+
				LDA STOREPOSITION
				CLC
				ADC #$08	;9 BECAUSE CAN ONLY MEASURE >=
				CMP CHECKPLAYERBOUND
				BCC :+
			;TEST Y
				;CHECK HERE FOR PLAYER COLLISION HEIGHT ON THIS LEVEL
				LDA BITTMPY
				AND #$0F	;MASK HIGH 4 BITS
				SEC
				SBC CURRENTZ	;RESULT IS ALWAYS GREATER THAN 0
				STA BITTMPA+1	;YES, IT HAS RESERVE 2
				LDX #$00
				LDA #$00
				ADDOVERHEIGHT:
					CLC	
					ADC #$04
					INX
					CPX #$04
					BCS ENDADDOVERHEIGHT
					CPX BITTMPA+1
					BNE ADDOVERHEIGHT
				ENDADDOVERHEIGHT:
					STA OVERFLOWHEIGHTPERLAYER	;WILL ONLY EVER BE 3, 6, 9, 12, 15, 18 DEPENDING ON CURRENTZ
					
			LDA CHECKPLAYERBOUND+1
			CMP STOREPOSITION+1
			BCC :+
				LDA STOREPOSITION+1
				CLC
				ADC OVERFLOWHEIGHTPERLAYER
				CMP CHECKPLAYERBOUND+1
				BCC :+
				;YES IT IS WITHIN THIS BOX, COPY TO OVERFLOW BUFFER
				JMP :++
			:
				JMP NEXTINOVERLAY
			:
			LDA BITTMPA
			CMP #$80
			BCC :+	
					LDA BITTMPA
					SEC
					SBC #$80
					STA BITTMPA
				LDA #$02	;2ND HALF OF BLOCKS
				JMP :++
			:
				LDA #$01	;FIRST HALF OF BLOCKS
			:
			STA RAMBANK	;SET TO PROPER BANK
			LDA BITTMPA
			STA FA
			LDA #$40
			STA FB
			JSR MULT
			LDA FA
			STA POINTER
			LDA FB
			CLC
			ADC #$A0
			STA POINTER+1	;POINT TO PROPER BLOCK DATA
			;SET TO RIGHT BUFFER COORDINATES
			LDA STOREPOSITION+1
			LDA PLAYERCOR+1	;Y
			SEC
			SBC STOREPOSITION+1
			ASL
			ASL
			ASL
			ASL	;*16	;# OF PIXELS OVER TOP
			SEC
			SBC #$30
			STA BITTMPA
			LDA #$00
			SEC
			SBC BITTMPA
			STA BITTMPA
			
			LDA PLAYERCOR	;X
			SEC
			SBC STOREPOSITION	;#OF PIXELS OVER IN BUFFER ON RIGHT SIDE
			EOR #$FF	;BITWISE NOT
			AND #$0F	;MASK OUT TOP BITS
			SEC
			SBC #$07
			CLC
			ADC BITTMPA
			TAX
			
			LDY #$00
			LDA #$00
			STA BITTMPA
				:
				LDA (POINTER), Y
				CMP #$00
				BEQ AFTEROVERPLACE
					STA OVERLAYBUFFER, X
					AFTEROVERPLACE:
				INX
				INY
				CPY #$40
				BEQ :+
				INC BITTMPA
				LDA BITTMPA
				CMP #$08
				BNE :-
				LDA #$00
				STA BITTMPA
				TXA
				CLC
				ADC #$08
				TAX
				CPX #$10
				BCC :+	;END IT ALL AFTER LOOPED OVER TOP
				JMP :-
			:
				
			LDA COMPASSPOINTER+4	;CENTER CHUNK
			STA RAMBANK	;SET TO CENTRAL CHUNK
			
		NEXTINOVERLAY:
		INC BITTMPY
			;SUBTRACT 3 FROM THE STORE POSITION
			LDA STOREPOSITION+1
			SEC
			SBC #$03
			STA STOREPOSITION+1
		;CHECK IF Y OVERFLOW
		LDA BITTMPY
		CMP #$00
		BNE :+
			INC POINTER2+1
		:
		LDA BITTMPY
		AND #$0F	;CHECK IF HIT 16 BLOCKS YET
		BEQ :+	
			JMP CHECKOVERLAY
		:
		INC BITTMPX
		LDX CURRENTLINE
		LDA LINELENGTH, X	;GIVES LENGTH OF CURRENT LINE
		CMP BITTMPX
		BEQ NEXTOVERLAYLINE
			;ELSE INCREASE STOREPOSITION BY +8
			LDA STOREPOSITION
			CLC
			ADC #$08
			STA STOREPOSITION
			;AND RESET STOREPOSITION+1
			LDA LOADPOSITION+1
			STA STOREPOSITION+1
			JMP OVERLAYCALCLOOP
		NEXTOVERLAYLINE:
			LDA CURRENTLINE
			CMP #$1E	;31 LINES IN A BLOCK
			BEQ ENDOVERLAYCALC
			;IF CURRENTLINE IS < 16, DECREASE LOADPOSITION BY 4
			;ELSE INCREASE BY 4
			CMP #$0F
			BCS :+ 
				LDA LOADPOSITION
				SEC
				SBC #$04
				STA LOADPOSITION
				STA STOREPOSITION
				JMP :++
			:
				LDA LOADPOSITION
				CLC
				ADC #$04
				STA LOADPOSITION
				STA STOREPOSITION
			:
			;INCREASE LOADPOSITION+1 BY 3
			LDA LOADPOSITION+1
			CLC
			ADC #$03
			STA LOADPOSITION+1
			STA STOREPOSITION+1
			;INCREASE CURRENTLINE AND RESET OTHER VARS
			INC CURRENTLINE
			LDA #$00
			STA BITTMPX
			JMP OVERLAYCALCLOOP
	
	ENDOVERLAYCALC:	
		;CLEAROVERLAY ON SCREEN
		JSR CLEAROVERLAY
		DRAWBUFFEROVERLAYTOLAYER1:
		;CACLULATE OVERLAY COORDINATES:
		LDA PLAYERCOR+1
		SEC
		SBC #$0F	;Y-16LINES
		STA FA
		LDA #$A0
		STA FB
		JSR MULT
		LDA FA
		ASL
		STA FA
		LDA FB
		ROL
		STA FB
		
		LDA PLAYERCOR
		SEC
		SBC #$08	;X-8
		CLC
		ADC FA
		STA ADDRL
		STA LASTBUFFERLOC
		LDA #$98		;ADD BASE OF $09800 FOR LAYER 1
		ADC FB
		STA ADDRM
		STA LASTBUFFERLOC+1
		LDA #$10
		ADC #$00
		STA ADDRH
		STA LASTBUFFERLOC+2
		;DRAW OVERLAY TO SCREEN AT PLAYERCOR -8, PLAYERCOR+1 -1
		LDA #$00
		STA OVERLAYON	;RESET OVERLAY ON
	
		LDX #$00
		:
			LDA OVERLAYBUFFER, X
			CMP #$00
			BEQ B_OVERLAY
				INC OVERLAYON
				STA DATA0
				JMP OK
			B_OVERLAY:
				LDA DATA0	;TO KEEP IT IN LINE
			OK:
			INX
			CPX #$00
			BEQ ENDDRAWOVERLAY
			TXA
			AND #$0F
			BNE :-
				;ELSE MOVE DOWN ADDRESS 304 ($130)
				LDA ADDRL
				CLC
				ADC #$30
				STA ADDRL
				LDA ADDRM
				ADC #$01
				STA ADDRM
				LDA ADDRH
				ADC #$00
				STA ADDRH
			JMP :-
		
	ENDDRAWOVERLAY:	
		;CHECK OVERLAYON (0-OFF, 1-ON)
		LDA OVERLAYON
		CMP OVERLAYONETHRESHHOLD	;OVERLAYONTHRESHOLD (IN NUMBER OF PIXELS
		BCS :+
			LDA #$00
			STA OVERLAYON
			JMP :++
		:
			LDA #$01
			STA OVERLAYON
		:
		JSR SETSPRITEOVERLAY
	RTS

;]

CLEAROVERLAY:
;[	CLEARS THE OVERLAY ON LAYER1
	LDA LASTBUFFERLOC+2
		CMP #$FF	;THIS WILL NEVER OCCUR NATURALLY, ONLY AS THE INITIAL VALUE
		BEQ ENDCLEAROVERLAY
		
		LDA LASTBUFFERLOC
		STA ADDRL
		LDA LASTBUFFERLOC+1
		STA ADDRM
		LDA LASTBUFFERLOC+2
		STA ADDRH
		
		LDX #$00
		LDA #$00
		:		;CLEARS THE LAST BUFFER
		LDA #$00
		STA DATA0
		INX
		CPX #$00
		BEQ ENDCLEAROVERLAY
		TXA
		AND #$0F
		BNE :-
			;ELSE MOVE DOWN ADDRESS 304 ($130)
			LDA ADDRL
			CLC
			ADC #$30
			STA ADDRL
			LDA ADDRM
			ADC #$01
			STA ADDRM
			LDA ADDRH
			ADC #$00
			STA ADDRH
		JMP :-
	ENDCLEAROVERLAY:
		RTS
;]

HEXDIGITTOCHAR:
;[ TAKES 0-F AND RETURNS [$30-$39, $01-$06]
	CMP #$0A
	BCC :+
		SEC
		SBC #$09
		RTS
	:
	CLC
	ADC #$30
	RTS
;]

DRAWITEMSONBAR:	;USES POINTER AND POINTER2
;[	;FILLS IN INVENTORY ITEMS ON LOWER BAR IN LAYER 1
	;OVERWRITE THE ITEMS ON THE BAR IN VRAM
	;INVENTORYVRAMBUFFERPOINTER
	;COPY FIRST 8 INVENTORY BLOCK/ITEM TO THE INVENTORYVRAMBUFFERPOINTER
	LDX #$00
	DRAWINVENTORY:
		LDA INVENTORY, X	;TYPE
		STA RENDERTMPA
		INX
		LDA INVENTORY, X	;AMOUNT
		STA RENDERTMPX
		INX
		;GET WHAT IT IS
		LDA RENDERTMPA
		CMP #$80
		BCS BUFFERITEM
			;IS BLOCK GET BLOCK
			LDA BLOCKSBANK
			STA RAMBANKTMP+1	;TEMPORARY STOREAGE
			JMP ADDTOINVBUFFER
		BUFFERITEM:
			SEC
			SBC #$80
			STA RENDERTMPA	;GET PURE ITEM NUMBER
			LDA ITEMSBANK
			STA RAMBANKTMP+1	;TEMPORARY STOREAGE
		ADDTOINVBUFFER:
			;SET POINTER OF OBJECT
			LDY #$00
			STY RENDERTMPA+1
			:
				ASL RENDERTMPA
				ROL RENDERTMPA+1
				INY
				CPY #$06	; * 64
				BNE :-
			LDA RENDERTMPA
			STA POINTER
			LDA RENDERTMPA+1
			CLC
			ADC #$A0
			STA POINTER+1
			;SET POINTER2
			LDA INVENTORYVRAMBUFFERPOINTER
			STA POINTER2
			LDA INVENTORYVRAMBUFFERPOINTER+1
			STA POINTER2+1
			 ;+ (64 * (X/2)) = (32 * X)
			LDY #$00
			STY RENDERTMPA+3
				;CPX #$00
				;BEQ :+	;SKIP FIRST TIME AROUND
			TXA
			DEC
			DEC
			STA RENDERTMPA+2
			:
				ASL RENDERTMPA+2
				ROL RENDERTMPA+3
				INY
				CPY #$05	; * 32
				BNE :-
				
			LDA POINTER2
			CLC
			ADC RENDERTMPA+2
			STA POINTER2
			LDA POINTER2+1
			ADC RENDERTMPA+3
			STA POINTER2+1
				
			LDY #$00
			:
				LDA RAMBANKTMP+1
				STA RAMBANK
			LDA (POINTER), Y
			STA RENDERTMPA+2
				LDA ITEMFRAMEBANK
				STA RAMBANK
			LDA RENDERTMPA+2
			STA (POINTER2), Y
			INY
			CPY #$40
			BNE :-
		CPX #$10	;16, TWO BYTES FOR 8 SLOTS
		BEQ COPYINVENTORYTOVRAM
		JMP DRAWINVENTORY
		
	COPYINVENTORYTOVRAM:
		;STORE IN VRAM
			;RESET POINTER2
			LDA INVENTORYVRAMBUFFERPOINTER
			STA POINTER2
			LDA INVENTORYVRAMBUFFERPOINTER+1
			STA POINTER2+1
		;INVENTORYVRAMLOCATION + $9800
		LDA INVENTORYVRAMLOCATION
		STA ADDRL
		LDA INVENTORYVRAMLOCATION+1
		CLC
		ADC #$98
		STA ADDRM
		LDA #$10
		ADC #$00
		STA ADDRH
		
		LDA #$08
		STA RENDERTMPA
		INVVRAMCOPYLOOP:
			LDX #$08
			LDY #$00
			:
				LDA (POINTER2), Y
				STA DATA0
				INY
				TYA
				AND #$07
				BNE :-
				DEX
				BEQ :+
				;ADD 320-8 TO DATA0
				LDA ADDRL
				CLC
				ADC #$38
				STA ADDRL
				LDA ADDRM
				ADC #$01
				STA ADDRM
				JMP :-
			:
			DEC RENDERTMPA
			LDA RENDERTMPA
			BEQ ENDDRAWITEMSONBAR
				;ADJUST POINTER 2
				LDA POINTER2
				CLC
				ADC #$40	;64
				STA POINTER2
				LDA POINTER2+1
				ADC #$00
				STA POINTER2+1
				;ADJUST DATA0 (-$8BC)
				LDA ADDRL
				SEC
				SBC #$BC
				STA ADDRL
				LDA ADDRM
				SBC #$08
				STA ADDRM
				;NO NEED TO ADJUST ADDRH HERE
			JMP INVVRAMCOPYLOOP
	
	ENDDRAWITEMSONBAR:
	RTS	
;]

DRAWITEMBAR:
;[	;DRAWS LOWER ITEM BAR ON LAYER 1 THEN CALLS DRAWITEMSONBAR
	;TOPLINE:
	LDA #$9F
	STA ADDRL
	LDA #$1C
	STA ADDRM
	LDA #$11
	STA ADDRH	;($0849F)
	LDY #$00
	:
	LDX #$00
	LDA INVENTORYBARCOLOR
	:
		STA DATA0
		INX
		CPX #$62	;LINE WIDTH
		BNE :-
		INY
		CPY #$02
		BEQ :+
		;ADD $222
		LDA ADDRL
		CLC
		ADC #$DE
		STA ADDRL
		LDA ADDRM
		ADC #$00
		STA ADDRM
		JMP :--
	:
	;BOTTOMLINE:
	LDA #$9F
	STA ADDRL
	LDA #$2B
	STA ADDRM	;($09395)
	LDY #$00
	:
	LDX #$00
	LDA INVENTORYBARCOLOR
	:
		STA DATA0
		INX
		CPX #$62	;LINE WIDTH
		BNE :-
		INY
		CPY #$02
		BEQ :+
		;ADD $222
		LDA ADDRL
		CLC
		ADC #$DE
		STA ADDRL
		LDA ADDRM
		ADC #$00
		STA ADDRM
		JMP :--
	:
	;VERTICAL LINES
	LDA #$1F
	STA ADDRL
	LDA #$1F
	STA ADDRM
	LDA #$E1
	STA ADDRH	;($0871F) STEPPING DOWN 320 EACH DATA0
	LDX #$00
	LDY #$00
	LDA INVENTORYBARCOLOR
	:
		STA DATA0
		INX
		CPX #$0A	;LINE WIDTH
		BNE :-
		;SUBTRACT (320*10) - 1 (C7F)
		LDA ADDRL
		SEC
		SBC #$7F
		STA ADDRL
		LDA ADDRM
		SBC #$0C
		STA ADDRM
		LDA INVENTORYBARCOLOR
	:
		STA DATA0
		INX
		CPX #$14	;20
		BNE :-
		INY
		CPY #$09
		BEQ ENDDRAWITEMBARBAR
		;SUBTRACT (320*10) - 11 (C75)
		LDX #$00
		LDA ADDRL
		SEC
		SBC #$75
		STA ADDRL
		LDA ADDRM
		SBC #$0C
		STA ADDRM
		LDA INVENTORYBARCOLOR
		JMP :--
		
	ENDDRAWITEMBARBAR:
	
	;TMP SET INVENTORY HERE
	;HEY KID I'M WORKING ON THE INVENTORY STUFF AND DISPLAY
	;SELECTED ITEM FROM HOT BAR (SHOULD IT TRAVEL WITH PLAYER?, PROBABLY TOO BIG)
	;DISPLAY THEN GOTO REALLY DO MINEING STUFF EVEN WITH ITEMS
	;THEN AFTER THEN DO ITEMS SITTING ON THE OVERWORLD
	;HOW CAN PLACING BE MADE BETTER?
	
	;THEN TERRAIN GENERATION TOO? JEEZ, OKAY
	;THEN DO REALLY DO A BETA TEST RIGHT, YOU NEED A TITLE SCREEN AND SAVING WORLD DATA OH MAN
	;THIS IS SO MUCH TO DO. 
	
	JSR DRAWITEMSONBAR
	
	RTS
;]

OPENINVENTORY:
;[	;OPENS INVENTORY ON LAYER1 - USES POINTER, POINTER2, TMPA, TMPX, TMPY
	;SET INVENTORY OPEN
	LDA INVFLAGS
	ORA #$01
	STA INVFLAGS
	
	LDA #$00
	STA SETFRAME	;NO PROCESSING VSYNC
	
	;CLEAR THE FIRST 78 LINES OF THE VRAMBUFFER
		LDA #<VRAMBUFFER
		STA POINTER
		LDA #>VRAMBUFFER
		STA POINTER+1
	LDX #$00
	LDY #$00
	LDA #$00
	:	;CLEAR $3100
		STA (POINTER), Y
		INY
		BNE :-
		INC POINTER+1
		INX
		CPX #$31
		BNE :-
	
	;DRAW INVENTORY FRAME TO THE VRAMBUFFER FROM 
		JSR CREATEINVENTORYOUTLINE
	
	;DRAW INVENTORY BLOCKS / ITEMS IN PROPER POSITION
		LDA #<VRAMBUFFER
			CLC
			ADC #$02
		STA LOADPOSITION
		LDA #>VRAMBUFFER
			ADC #$2A
		STA LOADPOSITION+1
	
	LDA #$04
	STA RENDERTMPY
	LDA #$00
	STA RENDERTMPX
	:
		LDA LOADPOSITION
		STA POINTER
		LDA LOADPOSITION+1
		STA POINTER+1
		
		LDA RENDERTMPX	;INV NUMBER
		JSR INVENTORYOBJTOPOINTER
		
		INC RENDERTMPX
		LDA RENDERTMPX
		AND #$07
		BEQ :+
			;ADJUST LOADPOSITION + 12
			LDA LOADPOSITION
			CLC
			ADC #$0C
			STA LOADPOSITION
			LDA LOADPOSITION+1
			ADC #$00
			STA LOADPOSITION+1
		JMP :-
	:
		DEC RENDERTMPY
		BEQ :+
		;ADJUST LOADPOSITION - $67D4
		LDA LOADPOSITION
		SEC
		SBC #$D4
		STA LOADPOSITION
		LDA LOADPOSITION+1
		SBC #$07
		STA LOADPOSITION+1
		JMP :--
	:
	
	;COPY TO LAYER 1, AND THEN CLEAR THE LAST 12 LINES OF LAYER 1
		;START AT LINE 21, @$0B240
	LDA #$40
	STA ADDRL
	LDA #$B2
	STA ADDRM
	LDA #$10
	STA ADDRH
		LDA #<VRAMBUFFER
		STA POINTER
		LDA #>VRAMBUFFER
		STA POINTER+1
	LDX #$00
	LDY #$00
	:	;TOTAL 78 LINES
		LDA (POINTER), Y
		STA DATA0
		INY
		CPY #$A0
		BNE :-
			INX
			CPX #$4E	;78
			BEQ :+
			LDY #$00
			LDA POINTER
			CLC
			ADC #$A0
			STA POINTER
			LDA POINTER+1
			ADC #$00
			STA POINTER+1
			;ADJSUT DATA0 TO NEXT LINE
			LDA ADDRL
			CLC
			ADC #$A0
			STA ADDRL
			LDA ADDRM
			ADC #$00
			STA ADDRM
			LDA ADDRH
			ADC #$00
			STA ADDRH
			JMP :-
		:
		
	CLEARINVENTORYBAR:	;STRAIGHT INTO THE VRAM
		;11C9F
		LDA #$9F
		STA ADDRL
		LDA #$1C
		STA ADDRM
		LDA #$11
		STA ADDRH
		
		LDX #$00
		LDY #$00
		LDA #$00
		:
			STA DATA0
			INX
			CPX #$62	;98
			BNE :-
			INY
			CPY #$0E
			BEQ :+
			LDX #$00
			;ADD $DE TO DATA0
			LDA ADDRL
			CLC
			ADC #$DE
			STA ADDRL
			LDA ADDRM
			ADC #$00
			STA ADDRM
			LDA ADDRH
			ADC #$00
			STA ADDRH
			LDA #$00
			JMP :-
		:
			

	ENDOPENINVENTORY:
		JSR DRAWINVCURSORS
		LDA #$01
		STA SETFRAME	;ALLOW PROCESSING VSYNC
	RTS
;]

CLOSEINVENTORY:
;[
	;SET IN INVENTORY TO FALSE
	LDA INVFLAGS
	AND #$F6		;TURN OFF INVENTORY OPEN AND 2ND CURSOR ON FLAGS
	STA INVFLAGS	;CLOSE INVENTORY 
	LDA #$00
	STA SETFRAME	;NO PROCESSING VSYNC
	
	;CLEAR THE SCREEN 
		;START AT LINE 21, @$0B25F
		;THEN CLEAR 78 ($4E) LINES OF WIDTH 98 ($62)
		LDA #$5F
		STA ADDRL
		LDA #$B2
		STA ADDRM
		LDA #$10
		STA ADDRH
		LDX #$00
		LDY #$00
		:
			LDA #$00
			STA DATA0
			INX
			CPX #$62
			BNE :-
			INY
			CPY #$4E
			BEQ :+
			;NEXT LINE
			LDX #$00
			;INCREASE DATA0 BY 222 (DE)
			LDA ADDRL
			CLC
			ADC #$DE
			STA ADDRL
			LDA ADDRM
			ADC #$00
			STA ADDRM
			LDA ADDRH
			ADC #$00
			STA ADDRH
			JMP :-
		:
	;REDRAW THE INVENTORY BAR
		JSR DRAWITEMBAR
	;RETURN ITEMS IN CRAFTING SLOTS TO INVENTORY SLOTS AND CLEAR CRAFTING RESULT
	
	;REDUCE CURRENTINV
	LDA CURRENTINV
	AND #$07	;ONLY 0-7 SLOTS
	STA CURRENTINV
	
	ENDCLOSEINVENTORY:
		LDA #$01
		STA SETFRAME	;OK TO PROCESS VSYNC
		JSR DRAWINVCURSORS
	RTS
;]

DRAWINVCURSORS:
;[	ADJUST CURRENT INVENTORY CURSOR SPRITES	
	LDA ITEMFRAMEBANK
	STA RAMBANK
	
	;SET DATA0
	LDA INVSPRITEPOINTER
	CLC
	ADC #$02	;TO GET X
	STA ADDRL
	LDA INVSPRITEPOINTER+1
	STA ADDRM
	LDA #$21	;TWO BYTE STEP
	STA ADDRH
	
	LDA INVFLAGS
	AND #$01
	BNE SETOPENINVENTORYCURSORS
	SETCLOSEDINVENTORYCURSORS:
		LDA CURRENTINV
		AND #$07	;ONLY BETWEEN 0-7
		STA CURRENTINV
		ASL	; * 2
		TAX
		
		LDA INVENTORYSLOTXY, X
		STA DATA0
		LDA INVENTORYSLOTXY+1, X
		CLC
		ADC #$15	;21
		STA DATA0
	
	JMP SET2NDINVCURSOR
	
	SETOPENINVENTORYCURSORS:
		;GET NEW LOCATION
		LDA CURRENTINV
		ASL	; * 2
		TAX
		
		LDA INVENTORYSLOTXY, X
		STA DATA0
		LDA INVENTORYSLOTXY+1, X
		STA DATA0
		
	SET2NDINVCURSOR:	;------------------------
	;SET DATA0
	LDA INVSPRITEPOINTER+2
	CLC
	ADC #$02	;TO GET X
	STA ADDRL
	LDA INVSPRITEPOINTER+3
	STA ADDRM
	LDA #$21	;TWO BYTE STEP
	STA ADDRH
	
	LDA INVFLAGS
	AND #$08
	BEQ SETCLOSEDINVENTORYCURSOR2 
	
	LDA INVFLAGS
	AND #$01
	BNE SETOPENINVENTORYCURSOR2
	SETCLOSEDINVENTORYCURSOR2:	;HIDE IT
		LDA #$F0
		STA DATA0
		STA DATA0
	
	JMP ENDDRAWINVCURSORS
	
	SETOPENINVENTORYCURSOR2:
		;GET NEW LOCATION
		LDA CURRENTINV2
		ASL	; * 2
		TAX
		LDA INVENTORYSLOTXY, X
		STA DATA0
		LDA INVENTORYSLOTXY+1, X
		STA DATA0
	
	ENDDRAWINVCURSORS:
	RTS
;]

SETINVENTORYSLOTXY:
;[	SETS INVENTORYSLOTXY'S 40 2 BYTE X,Y ON SCREEN LCOATIONS
	LDA ITEMFRAMEBANK
	STA RAMBANK
	
	LDA #$21	;STARTINGX
	STA TMPX
	LDA #$57
	STA TMPY	;STARTINGY
	
	LDX #$00
	LDY #$00
	:
		LDA TMPX
		STA INVENTORYSLOTXY, X
		INX
		LDA TMPY
		STA INVENTORYSLOTXY, X
		INX
		CPX #$50	;80
		BEQ NEXTSETINVENTORYSLOTXY
		LDA TMPX
		CLC
		ADC #$0C	;12
		STA TMPX
		TXA
		AND #$0F	;EVERY 16
		BNE :-
		LDA TMPX
		SEC
		SBC #$60	;12 * 8
		STA TMPX
		LDA TMPY
		SEC
		SBC #$0C	;12
		STA TMPY
		JMP :-
	
	NEXTSETINVENTORYSLOTXY:	;TOP 8
		;46. 30
		LDA #45
		STA INVENTORYSLOTXY+64
		LDA #29
		STA INVENTORYSLOTXY+65
		STA INVENTORYSLOTXY+67
		STA INVENTORYSLOTXY+69
		STA INVENTORYSLOTXY+79	;ALSO LAST SLOT
		;58, 30
		LDA #57
		STA INVENTORYSLOTXY+66
		;70, 30
		LDA #69
		STA INVENTORYSLOTXY+68
		LDA #117
		STA INVENTORYSLOTXY+78
		
		LDA #93
		STA INVENTORYSLOTXY+70
		STA INVENTORYSLOTXY+74
		LDA #105
		STA INVENTORYSLOTXY+72
		STA INVENTORYSLOTXY+76
		LDA #35
		STA INVENTORYSLOTXY+71
		STA INVENTORYSLOTXY+73
		LDA #23
		STA INVENTORYSLOTXY+75
		STA INVENTORYSLOTXY+77
		
	ENDSETINVENTORYSLOTXY:
	RTS
;]

CREATEINVENTORYOUTLINE:
;[	CALLED AFTER VRAMBUFFER CLEARED
	;MAIN CASE LINES:
	;HORIZONTAL
		;31, 28 IN BUFFER	+($119F)
		LDA #<VRAMBUFFER
			CLC
			ADC #$9F
		STA POINTER
		LDA #>VRAMBUFFER
			ADC #$11
		STA POINTER+1
	
	LDA #$04
	STA TMPY
	
	LDX #$00
	LDY #$00
	LDA INVENTORYBARCOLOR
	:
		STA (POINTER), Y
		INY
		CPY #$62	;98
		BNE :-
		LDY #$00
			JSR BUFFERPOINTERNEXTLINE
			LDA INVENTORYBARCOLOR
		INX
		CPX #$02
		BNE :-
		;8 LINES OF (2, 10 PAUSE) * 8 + 2
	:
		LDA #$08
		STA TMPX
	:
		LDA INVENTORYBARCOLOR
		STA (POINTER), Y
		INY
		STA (POINTER), Y
		TYA
		CLC
		ADC #$0B
		TAY
		DEC TMPX
		BNE :-
		LDA INVENTORYBARCOLOR
		STA (POINTER), Y
		INY
		STA (POINTER), Y
		
		LDY #$00
			JSR BUFFERPOINTERNEXTLINE
		INX
		CPX #$0C
		BNE :--
		LDX #$00
		
		LDA INVENTORYBARCOLOR
		DEC TMPY
		BNE :---
	:
		STA (POINTER), Y
		INY
		CPY #$62	;98
		BNE :-
		LDY #$00
			JSR BUFFERPOINTERNEXTLINE
			LDA INVENTORYBARCOLOR
		INX
		CPX #$02
		BNE :-
	
	;3 ARMOR SLOTS	43, 6 (+$3EB)
		LDA #<VRAMBUFFER
			CLC
			ADC #$EB
		STA POINTER
		LDA #>VRAMBUFFER
			ADC #$03
		STA POINTER+1
	
		;TOP TWO LINES
		LDY #$00
		LDX #$00
		LDA INVENTORYBARCOLOR
		:
			STA (POINTER), Y
			INY
			CPY #$26	;38
			BNE :-
			LDY #$4A	;OUTPUT BLOCK
		:
			STA (POINTER), Y
			INY
			CPY #$56
			BNE :-
			
				LDY #$00
				JSR BUFFERPOINTERNEXTLINE
				LDA INVENTORYBARCOLOR
			INX
			CPX #$0E	;14
			BEQ INVCRAFTINGTABLEOUTLINE
			CPX #$02
			BEQ :+
				JMP :--
		:	;HORIZONTAL LINES
			STA (POINTER), Y
			INY
			STA (POINTER), Y
			INY
			CPY #$26	;38
			BEQ :+
			TYA
			CLC
			ADC #$0A
			TAY
			LDA INVENTORYBARCOLOR
			JMP :-
		:
			LDY #$54
			STA (POINTER), Y
			INY
			STA (POINTER), Y
			
				LDY #$00
				JSR BUFFERPOINTERNEXTLINE
				LDA INVENTORYBARCOLOR
			INX
			CPX #$0C
			BNE :--
			JMP :----	;ANOTHER TWO LINES
	
	;4x4 CRAFTING TABLE
	INVCRAFTINGTABLEOUTLINE:	;91, 0 (+$5B)
		LDA #<VRAMBUFFER
			CLC
			ADC #$5B
		STA POINTER
		LDA #>VRAMBUFFER
			ADC #$00
		STA POINTER+1	
		LDX #$00
		STX TMPX
		LDY #$00
		LDA INVENTORYBARCOLOR
		:
			STA (POINTER), Y
			INY
			CPY #$1A	;26
			BNE :-
				LDY #$00
				JSR BUFFERPOINTERNEXTLINE
				LDA INVENTORYBARCOLOR
			INX
			CPX #$02
			BNE :-
		:	;VERTICAL LINES
			STA (POINTER), Y
			INY
			STA (POINTER), Y
			INY
			CPY #$1A	;26
			BEQ :+
			TYA
			CLC
			ADC #$0A
			TAY
			LDA INVENTORYBARCOLOR
			JMP :-
		:
				LDY #$00
				JSR BUFFERPOINTERNEXTLINE
				LDA INVENTORYBARCOLOR
			INX
			CPX #$0C
			BNE :--
		
			LDX #$00
			LDY #$00
			INC TMPX
			LDA TMPX
			CMP #$02
			BEQ :+
				LDA INVENTORYBARCOLOR
			JMP :---
		:
			LDA INVENTORYBARCOLOR
		:
			STA (POINTER), Y
			INY
			CPY #$1A	;26
			BNE :-
				LDY #$00
				JSR BUFFERPOINTERNEXTLINE
				LDA INVENTORYBARCOLOR
			INX
			CPX #$02
			BNE :-
		
	RTS
;]

BUFFERPOINTERNEXTLINE:
;[	MICROFUNCTION TO INCREASE POINTER BY $A0
	LDA POINTER
	CLC
	ADC #$A0
	STA POINTER
	LDA POINTER+1
	ADC #$00
	STA POINTER+1
	RTS
;]

INVENTORYOBJTOPOINTER:
;[	COPIES THE 64 PIXEL IMAGE OF INVENTORY SLOT #A	[RANGE 0-40] 
	;TO VRAMBUFFER (BUT LOCATION STORED IN POINTER)
	ASL
	TAX
	LDA INVENTORY, X
	CMP #$80
	BCS LOADITEMBANK
		STA TMPA
		LDA BLOCKSBANK
		STA RAMBANK
		JMP :+
	LOADITEMBANK:
		SEC
		SBC #$80
		STA TMPA
		LDA ITEMSBANK
		STA RAMBANK
	:
	;GET ITEM * 64 FOR POSITION
	LDA TMPA
	LDX #$00
	STX TMPX
	:
		ASL TMPA
		ROL TMPX
		INX
		CPX #$06
		BNE :-
	;STORE POSITION IN POINTER2 + $A000
	LDA TMPA
	STA POINTER2
	LDA TMPX
	CLC
	ADC #$A0
	STA POINTER2+1
	;COPY POINTER2 TO POINTER1
	LDX #$00
	LDY #$00
	:
		LDA (POINTER2), Y
		STA (POINTER), Y
		INY
		CPY #$40
		BEQ :+
		INX
		CPX #$08
		BNE :-
			;POINTER + $98, SINCE Y IS INCREASED TOO
			LDA POINTER
			CLC
			ADC #$98
			STA POINTER
			LDA POINTER+1
			ADC #$00
			STA POINTER+1
		LDX #$00
		JMP :-
	:
	RTS
;]

SETSPRITEOVERLAY:
;[	TURNS IT EITHER ON OR OFF BASED ON OVERLAYON (0-OFF, 1-ON)
	;REALLY IT JUST TURNS THE X COORDINATE HIGH BIT ON
	LDA OVERSPRITE
		CLC
		ADC #$03	;GET THE X-HIGHBIT
	STA ADDRL
	LDA OVERSPRITE+1
	STA ADDRM
	LDA #$01
	STA ADDRH
		LDA OVERLAYON
		EOR #$01
		STA DATA0
	ENDSETSPRITEOVERLAY:
	RTS
;]

;]

;INVENTORY FUNCTIONS:
;[
CONFIRM2NDINVCURSOR:
;[	SETS THE 2ND INVENTORY CURSOR AT THE CURRENT INVENTORY CURSOR LOCATION
	LDA INVFLAGS
	ORA #$08	;4TH BIT
	STA INVFLAGS
	LDA CURRENTINV
	STA CURRENTINV2
	RTS
;]
SWAPINVCURSOR:	;USES TMPX, TMPY
;[	SWAPS THE 2 BYTES PER ITEM IN THE INVENTORY BASED ON CURSOR LOCATIONS
	LDA INVFLAGS
	AND #$F7
	STA INVFLAGS	;TURN OFF 4TH BIT
	
	;CHECK CONDITIONS
	LDA CURRENTINV
	CMP CURRENTINV2
	BNE :+
		RTS	;NO SWAP IF THE SAME
	:
	
	;SWAP THEM
	LDA CURRENTINV
	ASL
	TAX
	;TMP <- CURRENTINV
	LDA INVENTORY, X
	STA TMPX
	LDA INVENTORY+1, X
	STA TMPY
	
	LDA CURRENTINV2
	ASL
	TAY
	;CURRENTINV <- CURRENTINV2
	LDA INVENTORY, Y
	STA INVENTORY, X
	LDA INVENTORY+1, Y
	STA INVENTORY+1, X
	;CURRENTINV2 <- TMP
	LDA TMPX
	STA INVENTORY, Y
	LDA TMPY
	STA INVENTORY+1, Y
	
	
	;DRAW SLOT # CURRENTINV & CURRENTINV2
	;[
	LDA CURRENTINV
	STA TMPA	;USED FOR REFERENCE AND COUNTING
	DRAWSLOT:
	ASL
	TAX
		LDA ITEMFRAMEBANK
		STA RAMBANK
	LDA INVENTORYSLOTXY, X
	STA TMPX
	LDA INVENTORYSLOTXY+1, X
	STA TMPY
		INC TMPX	;GET CENTERED 8x8 OFFSET
		INC TMPY
	LDA TMPY
	STA FA
	LDA #$A0	;160
	STA FB
	JSR MULT
		ASL FA
		ROL FB	; * 2
	LDA FA
	CLC
	ADC TMPX	;ADD IN X OFFSET
	STA ADDRL
	LDA FB
	ADC #$98	;ADD IN VRAM OFFSET
	STA ADDRM
	LDA #$10
	ADC #$00
	STA ADDRH
	
	;GET BLOCK / ITEM
	LDA TMPA
	ASL
	TAX
	LDA INVENTORY, X	;BLOCK / ITEM TYPE
	CMP #$80
	BCS REDRAWSLOTITEMADJUSTMENT
		STA RENDERTMPA
		LDA BLOCKSBANK
		JMP :+
	REDRAWSLOTITEMADJUSTMENT:
		SEC
		SBC #$80
		STA RENDERTMPA
		LDA ITEMSBANK
	:
	STA RAMBANK
	LDA #$00
	STA RENDERTMPA+1
	LDX #$06	; * 2^6 (64)
	:
		ASL RENDERTMPA
		ROL RENDERTMPA+1
		DEX
		BNE :-
		
	LDA RENDERTMPA
	STA POINTER
	LDA RENDERTMPA+1
	CLC
	ADC #$A0
	STA POINTER+1
	
	LDY #$00
	LDX #$00
	:
		LDA (POINTER), Y
		STA DATA0
		INY
		CPY #$40
		BEQ :+
		INX
		CPX #$08
		BNE :-
		LDX #$00
		;INCREASE DATA0 BY 312 ($138)
		LDA ADDRL
		CLC
		ADC #$38
		STA ADDRL
		LDA ADDRM
		ADC #$01
		STA ADDRM
		LDA ADDRH
		ADC #$00
		STA ADDRH
		JMP :-
	:
		LDA TMPA
		CMP CURRENTINV
		BNE :+
			;ELSE FIRST TIME AROUND SWITCH TO CURRENTINV2
			LDA CURRENTINV2
			STA TMPA
			JMP DRAWSLOT
		:
	;]
	
	RTS
;]


;]


CREATIVEINVENTORY:
;[	SETTING UP CREATIVE MODE INVENTORY
	LDX #$00
	LDA #$01		;DIRT
	STA INVENTORY, X
		INX
		INX
	LDA #$0C		;LOG 1
	STA INVENTORY, X
		INX
		INX
	LDA #$0D		;PLANKS1
	STA INVENTORY, X
		INX
		INX
	LDA #$18		;SAND
	STA INVENTORY, X
		INX
		INX
	LDA #$1B		;STONE
	STA INVENTORY, X
		INX
		INX
	LDA #$03		;WHEAT
	STA INVENTORY, X
		INX
		INX
	LDA #$0A		;FARM
	STA INVENTORY, X
		INX
		INX
	LDA #$0B		;TREE 1
	STA INVENTORY, X
		INX
		INX
	LDA #$0E		;TREE 2
	STA INVENTORY, X
		INX
		INX
	LDA #$0F		;LOG2
	STA INVENTORY, X
		INX
		INX
	LDA #$10		;PLANKS2
	STA INVENTORY, X
		INX
		INX
	LDA #$11		;TREE3
	STA INVENTORY, X
		INX
		INX
	LDA #$12		;LOG 3
	STA INVENTORY, X
		INX
		INX
	LDA #$13		;PLANKS 3
	STA INVENTORY, X
		INX
		INX
	LDA #$14		;TREE 4
	STA INVENTORY, X
		INX
		INX
	LDA #$15		;LOGS 4
	STA INVENTORY, X
		INX
		INX
	LDA #$16		;PLANKS 4
	STA INVENTORY, X
		INX
		INX
	LDA #$17		;LEAVES
	STA INVENTORY, X
		INX
		INX
	LDA #$1A		;GLASS
	STA INVENTORY, X
		INX
		INX
	LDA #$1C		;COBBLE
	STA INVENTORY, X
		INX
		INX
	LDA #$1D		;SMOOTH
	STA INVENTORY, X
		INX
		INX
	LDA #$1E		;OBSIDIAN
	STA INVENTORY, X
		INX
		INX
	LDA #$24		;BEDROCK
	STA INVENTORY, X
		INX
		INX
	LDA #$25		;BRICKS
	STA INVENTORY, X
		INX
		INX
	LDA #$27		;BAMBOO
	STA INVENTORY, X
		INX
		INX
	LDA #$29		;ICE
	STA INVENTORY, X
		INX
		INX
	LDA #$1F		;DIAMOND ORE
	STA INVENTORY, X
		INX
		INX
	LDA #$20		;IRON ORE
	STA INVENTORY, X
		INX
		INX
	LDA #$21		;COPPER ORE
	STA INVENTORY, X
		INX
		INX
	LDA #$42		;GOLD ORE
	STA INVENTORY, X
		INX
		INX
	LDA #$22		;COAL ORE
	STA INVENTORY, X
		INX
		INX
	LDA #$05		;WATER
	STA INVENTORY, X
		INX
		INX
	LDA #$06		;LAVA
	STA INVENTORY, X
		INX
		INX
	
	;WATER
	;LAVA
	RTS

	
	RTS
;]

;[	TITLE THINGS
TITLEHANDLER:
;[	VSYNC CODE WHEN TITLE IS ON
	LDA SETFRAME
	CMP #$01
	BEQ :+
		JMP ENDTITLE
	:
	LDA TITLEFLAGS
	AND #$02	;2ND BIT
	BEQ :+
	JMP TITLELOADED	;TITLE LOADED
	:
		LDA TITLEFLAGS
		ORA #$02
		STA TITLEFLAGS
		JSR LOADTITLETOVRAM
		;SET CRAFTSCII BUFFER
		LDA CRAFTSCIIBANK
		STA RAMBANK
		
		LDA #<VRAMBUFFER
		STA POINTER2
		LDA #>VRAMBUFFER
		STA POINTER2+1
		
		LDX #$00
		:
			LDA TITLESTARTMESSAGE, X
				STX TMPX
				SEC
				SBC #$C0
			STA FA
			LDA #$40	;64
			STA FB
			JSR MULT
				LDX TMPX
			LDA FA
			STA POINTER
			LDA FB
			CLC
			ADC #$A0
			STA POINTER+1
			LDY #$00
			:
				LDA (POINTER), Y
				BEQ NOCOLORTEXT
					CLC
					ADC #$0C	;TITLE COLOR OFFSET
				NOCOLORTEXT:
				STA (POINTER2), Y
				INY
				TYA
				AND #$07
				BNE :-
				;ELSE INCREASE POINTER2 BY 152
				LDA POINTER2
				CLC
				ADC #$98
				STA POINTER2
				LDA POINTER2+1
				ADC #$00
				STA POINTER2+1
				CPY #$40
				BNE :-
				
				LDA POINTER2	;DECREASE BY (160 * 8) - 8 = $4F8
				SEC
				SBC #$B8
				STA POINTER2
				LDA POINTER2+1
				SBC #$04
				STA POINTER2+1
			INX
			CPX #$0B
			BNE :--

		
	TITLELOADED:
	INC TITLECOUNTER+1
	LDA TITLECOUNTER+1
	AND #$03
	CMP #$02
	BEQ :+
		JMP ENDTITLECARD
	:
	INC TITLECOUNTER
	LDA TITLECOUNTER
	CMP #$20
	BNE :+
		JMP CLEARTITLECOUNTER
	:
	CMP #$10
	BNE :+
		JMP CLEARTITLECARD
	:
	CMP #$00
	BEQ :+
		JMP ENDTITLECARD
	:
		;COPY TO VRAM
		LDA #$E4
		STA ADDRL
		LDA #$85
		STA ADDRM
		LDA #$10
		STA ADDRH
		
		LDA #<VRAMBUFFER
		STA POINTER2
		LDA #>VRAMBUFFER
		STA POINTER2+1
		
		LDX #$00
		:
		LDY #$00
		:
			LDA (POINTER2), Y
			STA DATA0
			INY
			CPY #$58
			BNE :-
			LDA ADDRL
			CLC
			ADC #$E8
			STA ADDRL
			LDA ADDRM
			ADC #$00
			STA ADDRM
				LDA POINTER2
				CLC
				ADC #$A0
				STA POINTER2
				LDA POINTER2+1
				ADC #$00
				STA POINTER2+1
			INX
			CPX #$08
			BNE :--
		JMP ENDTITLECARD
	CLEARTITLECARD:
		;COPY TO VRAM
		LDA #$E4
		STA ADDRL
		LDA #$85
		STA ADDRM
		LDA #$10
		STA ADDRH
		
		LDX #$00
		:
		LDY #$00
		:
			LDA #$00
			STA DATA0
			INY
			CPY #$58
			BNE :-
			LDA ADDRL
			CLC
			ADC #$E8
			STA ADDRL
			LDA ADDRM
			ADC #$00
			STA ADDRM
			INX
			CPX #$08
			BNE :--
			JMP ENDTITLECARD
	CLEARTITLECOUNTER:
		LDA #$FF
		STA TITLECOUNTER
	ENDTITLECARD:
	LDA TITLECOUNTER
	CMP #$06
	BCS :+
		JMP ENDTITLE
	:
	;CHECK CONTROLLER:
	JSR JOYSTICK_SCAN
	LDA #$01	;ATTEMPT TO GET JOY[1] --> PLUGGED IN
	JSR JOYSTICK_GET
	;STORE CONTROLLER
	CPY #$FF	;I'M NOT GETTING NEGATIVE ONE ON EMULATOR, BUT IT SHOULD BE
	BNE :+
		;NO JOY[1] GET JOY[0] (KEYBOARD)
		JSR JOYSTICK_SCAN
		LDA #$00
		JSR JOYSTICK_GET
	:
	STA CONTR	;LOW
	STX CONTR+1	;HIGH

	LDA CONTR
	AND #$10
	BNE :+
		;LOAD GAME
		LDA #$00
		STA SETFRAME
			LDA DC_VIDEO
			AND #%000001111
			STA DC_VIDEO	;DISABLE VERA OUTPUT (BUT SHOULD SAVE THE OUTPUT MODE)
		JSR SETUPWORLD
		;TURN OFF TITLE
		LDA #$00
		STA TITLEFLAGS
			LDA DC_VIDEO
			ORA #%01110000
			STA DC_VIDEO	;ENABLE SPRITES, LAYER 1, LAYER 0
		LDA #$01
		STA SETFRAME	;ALLOW VSYNC GAME CODE
	:
	
	ENDTITLE:
	JMP (DEFAULTIRQVECTOR)
;]
	
;]

;MANAGING SPRITES:
SETSPRITES:
;[
	LDA #$00
	STA ADDRL
	LDA #$FC
	STA ADDRM
	LDA #$11
	STA ADDRH	;SET TO $1FC00
	
	LDX #$00
	:
		LDA SPRITEDATA, X
		STA DATA0
		INX
		CPX TOTALNUMOFSPRITEBYTES	;8 BYTES PER SPRITE
		BNE :-
	
	
;]
;MATH
MULT:		;MULTIPLIES TWO 8 BIT VALUES AND RETURNS A 16 BIT, SCRAMBLES A & X
			;HIGH RESULT IN FB, LOW RESULT IN FA
;[
	LDA #$00
	LDX #$08
	LSR FA
MLOOP:
	BCC NOADD
	CLC
	ADC FB
NOADD:
	ROR
	ROR FA
	DEX
	BNE MLOOP
	STA FB 
	RTS
;]

FILENAME: .BYTE "blocks";REMOVE THE MINE PART EVENTUALLY
OVERWRITE: .BYTE "@0:"
FILEFOLDER: .BYTE "world/"
CHUNKX: .BYTE $00, $00, $00, $00
DASH: .BYTE "-"
CHUNKY:	.BYTE $00, $00, $00, $00
ENDCHUNKNAME: .BYTE $00
PALNAME: .BYTE "pal"
ITEMNAME: .BYTE "items"
MOBNAME: .BYTE "mobs"
CRAFTSCIINAME: .BYTE "craftscii"
QUICKTABLENAME: .BYTE "quicktable"
INFOTABLENAME: .BYTE "infotable"
TITLEFILENAME: .BYTE "title"
TMPEND: .BYTE $00
VRAMTILEMAP = $00000
VRAMPALAT = $1FA00
VRAMMOBS = $12E00
VRAMTITLE = $00000

;VARIABLES & CONSTANTS
ZERO: .BYTE "0"
BLOCKSBANK: .BYTE $01, $02
ITEMSBANK: .BYTE $03
CRAFTSCIIBANK: .BYTE $04
QUICKTABLEBANK: .BYTE $05
INFOTABLEBANK: .BYTE $06
ITEMFRAMEBANK: .BYTE $07
ORTHTABLE = $BA00
RENDERTABLE = $BB00
RAMBANKTMP: .RES 2
TITLESTARTMESSAGE: .BYTE "PRESS START"
TEXTOFFSET: .BYTE $41	;TURNING DIGITS INTO ASCII
CHUNKBASE: .BYTE $10
SPEED: .BYTE $01, $00	;PIXEL AND SUBPIXEL
SPEEDBUFFER: .BYTE $00, $00, $00, $00	;TWO BYTES FOR X & 2 FOR Y
CHUNKOFFSETX: 		.BYTE $90, $D0, $10, $D0, $10, $50, $10, $50, $90	;IN PIXELS
CHUNKOFFSETY: 		.BYTE $38, $08, $D8, $68, $38, $08, $98, $68, $38


SCREENRESTRICTION:	.BYTE $10, $11, $01, $12, $00, $21, $02, $22, $20
CURRENTRESTRICTION: .RES 1
;RESTRICTING WHICH SECTION OF THE SCREEN CAN DRAW TO	$XY	-> 0 NONE, 1 LEFT OR TOP, 2 RIGHT OR BOTTOM
SCREENSIZE:	.BYTE $40, $40	;64, 64 TILES
CHUNKLOADINGSTORE: .RES 3
COMPASSTMPSTORE: .RES 3
RENDERTMPSTORE: .RES 3
MFLAG:	.RES 1
CHUNKSTORENDER:	.RES 9
TMPRENDERX: .RES 1
TMPSTOREOFFSET: .RES 2
VBUFFY: .RES 2
QUICKTMP: .RES 2
OLDCHUNKCOMPASS: .RES 3
GENTMPX: .RES 1
GENTMPY: .RES 1
GENTMPA: .RES 1
GENSEED: .RES 1
BLOCKADDRESS: .BYTE $00, $E0
CLOCKMAX: .BYTE $02
CURRENTBLOCK: .BYTE $FF, $0F	;TWO BYTES TO DETERMINE WHICH BLOCK IN THE CHUNK PLAYER IS ON
	;IN ORDER OF RENDER NUMBER
LASTCURRENTBLOCK: .BYTE $FF, $FF	;MUST BE SET IN CODE LATER
TMPCURRENTBLOCK: .RES 2
CURSORBLOCKNUM: .RES 2
TMPPLAYERCOR: .RES 2
CURRENTZ:	.BYTE $0F	;TOP LEVEL 15
TMPZ: .BYTE $00	;USED FOR GRAVITY
SCREENYOFFSET: .BYTE $06	;THIS IS THE NUMBER OF PIXELS THE SCREEN IS SHIFTED UP
CHECKPLAYERBOUND: .RES 4
INVENTORYBARCOLOR: .BYTE $66
TITLEFLAGS: .RES 1

;NEW VARS
BLOCKWIDTH: .RES 1
RENDERTMPA: .RES 4
RENDERTMPX: .RES 2
RENDERTMPY: .RES 1
RENDERTMPBANK: .RES 1
LINELENGTH: .BYTE $01, $02, $03, $04, $05, $06, $07, $08, $09, $0A, $0B, $0C, $0D, $0E, $0F, $10
			.BYTE $0F, $0E, $0D, $0C, $0B, $0A, $09, $08, $07, $06, $05, $04, $03, $02, $01
SCROLLOFFSET: .RES 2
RESTRICTTMP: .RES 1
SWAPXTMP: .RES 1
TMPCHECK: .RES 1
BITTMPX: .RES 1
BITTMPY: .RES 1
BITTMPA: .RES 2
HITBOX24X: 	.BYTE $03, $04, $01, $02, $03, $04, $05, $06, $00, $01, $02, $03
			.BYTE $04, $05, $06, $07, $01, $02, $03, $04, $05, $06, $03, $04
HITBOX24Y: 	.BYTE $00, $00, $01, $01, $01, $01, $01, $01, $02, $02, $02, $02
			.BYTE $02, $02, $02, $02, $03, $03, $03, $03, $03, $03, $04, $04


CORSTRING: .BYTE "X:00 Y:00 Z:00"	;LENGTH: 18

NOISETABLE: .incbin "NOISE.BIN"
HEIGHTTABLE: .RES 256	;ONE PAGE FOR REFERENCE HEIGHTS
FALLHEIGHTRACKER: .RES 2
FACINGBUFFER: .RES 1
LASTBUFFERLOC:	.BYTE $FF, $FF, $FF
OVERFLOWHEIGHTPERLAYER: .RES 1
LASTPLAYERCOR: .RES 2
CURRENTTMP: .RES 1
CURSORBUFFERPOS: .BYTE $00, $00
CURSORDELAY: .BYTE $00
CURSORBLOCKPRIORITY: .BYTE $00
PATCHTMP: .RES 3
PATCHTMPX: .RES 1
PATCHTMPY: .RES 1
PATCHTMPZ: .RES 1
PATCH: .RES 256
INVENTORYVRAMBUFFERPOINTER: .BYTE $00, $B6
INVENTORYVRAMLOCATION: .BYTE $62, $88	;WHERE TO PLACE INVENTORY ON BAR IN VRAM (LAYER 0)
INVENTORYSLOTXY = $B500	;IN ITEMFRAMEBANK
TOPROWINVTRANSFER: 	.BYTE $20, $20, $21, $22, $23, $23, $24, $27
					.BYTE $01, $02, $03, $25, $26, $05, $06, $07
BTMROWINVTRANSFER:	.BYTE $20, $20, $21, $22, $25, $25, $26, $27
					.BYTE $19, $1A, $1B, $1D, $1E, $23, $24, $1F
CURRENTINV2: .RES 1	;2ND INVENTORY CURSOR
MTIMESLICE: .BYTE $10	;TIME IN FRAMES
MININGTARGET: .RES 2
MICROTIMER: .BYTE $00
OVERLAYON: .BYTE $00
OVERLAYONETHRESHHOLD: .BYTE $38	;IN NUMBER OF PIXELS IN THE BUFFER
TITLECOUNTER: .BYTE $00, $00
HELDSELFOR: .BYTE $00
RELOAD: .BYTE $00

PLAYERSPRITEOFFSET: .BYTE %01110000
OVERLAYSPRITEOFFSET: .BYTE %10100000
SPRITEDATA:
;[	LIST OF ALL SPRITE DATA [8 BYTES EACH]	
	;HIGHLIGHT SPRITE
	.BYTE %10100000, %10001001	;ADDRESS & MODE	(FIRST POINTS TO $13200)
	.BYTE $01, %00000000	;X
	.BYTE $00, %00000000	;Y
	.BYTE %00001100, %01000000	;8x16 SPRITE ;COLLISION MASK, ZLEVEL(3), VFLIP, HFLIP, SPRITE H/W, PAL OFFSET
	;PLAYER SPRITE
	.BYTE %01110000, %10001001	;ADDRESS & MODE	(FIRST POINTS TO $12E00)
	.BYTE $4C, %00000000	;X
	.BYTE $36, %00000000	;Y
	.BYTE %00001000, %01000000	;8x16 SPRITE ;COLLISION MASK, ZLEVEL(2), VFLIP, HFLIP, SPRITE H/W, PAL OFFSET
	;CURSOR SPRITE
	.BYTE %10000000, %10001001	;ADDRESS & MODE	(FIRST POINTS TO $13000)
	.BYTE $00, %00000000	;X
	.BYTE $00, %00000000	;Y
	.BYTE %00001000, %00000000	;8x8 SPRITE ;COLLISION MASK, ZLEVEL(2), VFLIP, HFLIP, SPRITE H/W, PAL OFFSET
	
	;INVENTORY SELECTION SPRITE
	.BYTE %10010000, %10001001	;ADDRESS & MODE	(FIRST POINTS TO $13200)
	.BYTE $00, %00000000	;X
	.BYTE $00, %00000000	;Y
	.BYTE %00001100, %01010000	;16x16 SPRITE ;COLLISION MASK, ZLEVEL(3), VFLIP, HFLIP, SPRITE H/W, PAL OFFSET
	;INVENTORY SELECTION SPRITE 2
	.BYTE %10001000, %10001001	;ADDRESS & MODE	(FIRST POINTS TO $13100)
	.BYTE $00, %00000000	;X
	.BYTE $00, %00000000	;Y
	.BYTE %00001100, %01010000	;16x16 SPRITE ;COLLISION MASK, ZLEVEL(3), VFLIP, HFLIP, SPRITE H/W, PAL OFFSET
;]
TOTALNUMOFSPRITEBYTES: .BYTE $28	;[TOTALSPRITES: 5] * 8

;PLAYER SPRITE VARS
OVERSPRITE: .BYTE $00, $FC
PLAYERSPRITE: .BYTE $08, $FC	;POINTER TO @SPRITES $1FC08
FACING: .BYTE $00	;INCERASE BY 4
PLAYERCOR: .RES	2 ;X AND Y OF PLAYER'S CENTER FOOT
PLAYERCORTMP: .RES 2
BUTTONDELAY: .BYTE $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00, $00
		;12 DELAYS FOR ALL BUTTONS: A, B, X, Y, L, R, SEL, START, UP, DOWN, LEFT, RIGHT
STANDARDBUTTONDELAY: .BYTE $04	;USED BY Y, L, R, AND ARROW KEYS
LONGBUTTONDELAY: .BYTE $F0	;USED BY X
CURSORBUTTONDELAY: .BYTE $06	;USED BY INVENTORY CURSOR
BLANKSPRITELOCATION: .BYTE $8E	;LAST SPRITE ON ROW 1 (INTENTIONALLY LEFT BLANK)

CURSORSPRITEPOINTER: .BYTE $10, $FC	;@$1FC10
INVSPRITEPOINTER: .BYTE $20, $FC, $18, $FC	;TWO SPRITES @1FC18-1FC20




;COORDINATES OF THE BOUNDARY RECTANGLE
BOUNDARY: .incbin "BORDER.BIN"

;BUFFERS
INVENTORY: .RES 80	;80 BYTES, 32 ITEMS/BLOCKS, THREE ARMOR, FOUR CRAFTING, ONE CRAFTING RESULT
VRAMBUFFER:	.RES 19200	;$4B00 VRAM BUFFER
ENDVRAMBUFFER: .RES 1
OVERLAYBUFFER: .RES 256
SPRITESWAPBUFFERHIGH: .RES 8
SPRITESWAPBUFFERLOW: .RES 8
;BCS >=
;BCC <	